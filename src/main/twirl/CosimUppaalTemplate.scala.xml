@import core._
        @(m: ModelEncoding)
        <?xml version="1.0" encoding="utf-8"?>
        <!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
    <declaration>
        //***********************************************************************************************************
        //Do not change
        const int END_TIME = 1;
        const int START_TIME = 0;

        //Is the stepFinder active
        bool stepFinderActive := false;

        //We need to run an extra iteration of the stepFinder and loopSolver with all checks activated
        // once the loop has converged
        bool isLoopExtraIteration := false;
        bool isStepExtraIteration := false;

        //These is simply to keep track of which loop is the inner one - in case of nested loops
        bool isLoopNested := false;
        bool isStepNested := false;

        //Active loop - if it is different form -1, we are in the middle of solving an algebraic loop
        int loopActive := -1;

        //Used in Trace Visualization
        int isInit := 0;
        int isSimulation := 0;

        //In case of a scenario with algebraic loops and step rejection,
        // we need to be able to turn off the precondition checks
        bool shouldChecksBeDisabled(){

        //In case a loop is not activated all checks should be
        if(loopActive == -1 &amp;&amp; !stepFinderActive){
        return false;
        }

        //We are inside a loop is it nested
        if(isLoopNested || isStepNested){
        //Both loops should be on the extraIteration
        return !(isStepExtraIteration &amp;&amp; isLoopExtraIteration);
        }

        //Not nested - if none of the loops is in the extra iteration we should disable the checks
        if(!isLoopExtraIteration &amp;&amp; !isStepExtraIteration){
        return true;
        }

        return false;
        }

        //State of a variable
        const int undefined := 0;
        const int defined := 1;
        const int notStable :=-1;

        //State of the variable
        typedef struct {
        int[-1,1] status;
        int time;
        } variable;


        //Const assignment types - to future variables or current:
        const int final := 0;
        const int tentative := 1;
        const int noCommitment := -1;

        //***********************************************************************************************************

        //Max number of inputs/outputs any FMU can have - Should be changed
        const int MaxNInputs = @m.maxNInputs;
        const int MaxNOutputs = @m.maxNOutputs;

        //Numbers of FMUs in scenario - Should be changed
        const int nFMU = @m.nFMUs;

        //number of algebraic loops in scenario - Should be changed
        const int nAlgebraicLoopsInInit := @m.nAlgebraicLoopsInInit;
        const int nAlgebraicLoopsInStep := @m.nAlgebraicLoopsInStep;

        //***********************************************************************************************************
        //Do not change

        const int NActions := 14;

        //The number of actions in our system
        const int N := MaxNInputs &gt; MaxNOutputs? MaxNInputs : MaxNOutputs;

        //The maximum step allowed in system - shouldn't be changed
        const int H_max := @m.Hmax;
        const int H := H_max;

        const int noStep := -1;
        const int noFMU := -1;
        const int noLoop := -1;

        typedef struct {
            int[-1, nFMU] FMU;
            int[-1,NActions] act;
            int[-1,N] portVariable;
            int[-1,H] step_size;
            int[-1,nFMU] relative_step_size;
            int[-1,1] commitment;
            int[-1, nAlgebraicLoopsInStep] loop;
        } Operation;

        typedef struct {
            int[-1,nFMU] FMU;
            int[-1, MaxNInputs] input;
            int[-1, MaxNOutputs] output;
        } InternalConnection;

        //Types of input ports
        const int delayed := 0;
        const int reactive := 1;
        const int noPort := -1;

        typedef struct {
            int[0, nFMU] SrcFMU;
            int[0,MaxNOutputs] output;
            int[0,nFMU] TrgFMU;
            int[0,MaxNInputs] input;
        } ExternalConnection;

        typedef struct {
            int[-1,nFMU] FMU;
            int[-1, MaxNOutputs] port;
        } FmuOutputPort;


        //The action dictates which action will be executed
        const int noOp := -1;
        const int get := 0;
        const int set := 1;
        const int step := 2;
        const int save := 3;
        const int restore := 4;
        const int setParameter := 5;
        const int instantiate := 6;
        const int enterInitialization := 7;
        const int exitInitialization := 8;
        const int loop := 9;
        const int findStep := 10;
        const int setupExperiment := 11;
        const int unload := 12;
        const int terminate := 13;
        const int freeInstance := 14;

        int[-1,NActions] action;

        //The activeFMU variable dictates which FMU is enabled - which FMU should take an action
        int[-1, nFMU] activeFMU = 0;

        //Channels
        //A channel to invoke an FMU-action from the Interpreter, StepFinder, LoopSolver
        chan fmu[nFMU];

        //A channel for all actions - I can use fewer channels and use the actions to distinguish
        broadcast chan actionPerformed;

        //A channel to start the stepFinder
        chan findStepChan;

        //Channel to start and finish LoopSolver
        chan solveLoop;

        //Channel to start and finish LoopSolver for Init
        chan solveLoopInit;

        //A broadcase channel for an FMU to signal an error
        chan ErrorChan;

        //The fmu-variable that is updated by the action
        int [-1,N] var = 0;
        //The variable that is being get or set (either the current or future time) by the action
        int [-1,1] commitment = 0;
        //The stepsize of the step action
        int [-1, H_max] stepsize = 0;
        int [-1, nFMU] relative_step_size = 0;

        const int end = END_TIME;
        int time = START_TIME;

        //Counters to track the current state of the co-simulation
        int fmusUnloaded = 0;

        //***********************************************************************************************************
        //Scenario Dependent - Should be changed!

        //Number of internal connections - both init and normal
        const int nInternal := @m.nInternal;
        const int nInternalInit := @m.nInternalInit;

        //Number of external connections in scenario
        const int nExternal := @m.nExternal;

        //The initial of value of h
        int h := H_max;

        //This array is representing the variables of the stepSize that each FMU can take - H_max is the default value
        int stepVariables[nFMU] = {@m.stepVariables};

        //A generic action to pick the next action
        void unpackOperation(Operation operation){
            //action to be performed
            action := operation.act;
            //fmu to perform the action
            activeFMU := operation.FMU;
            //The variable involved
            var := operation.portVariable;
            //The Stepsize
            stepsize := operation.step_size;
            //The Stepsize
            relative_step_size := operation.relative_step_size;
            //The commitment
            commitment := operation.commitment;
            if(loopActive == noLoop){
                loopActive := operation.loop;
            }
            if(action == step){
                if (stepsize == noStep) {
                    // Step is relative to the fmu referred to by relative_step_size
                    stepsize := stepVariables[relative_step_size];
                } else if (stepsize == H) {
                    // Default step
                    stepsize := h;
                } else {
                    // Absolute step size
                    // Nothing to do.
                }
            }
        }


        //Encoding of the scenario
        //Each FMU should have a different ID \in [0, nFMU-1]
        @for(fName<- m.fmuNames) {
        const int @fName := @m.fmuId(fName);
        }

        //Number of inputs and outputs of each FMU
        @for(fName<- m.fmuNames) {
        const int @{fName}_input := @m.nInputs(fName);
        const int @{fName}_output := @m.nOutputs(fName);
        }

        //Definition of inputs and outputs of each FMU
        @for(fName<- m.fmuNames) {
        // @fName inputs - @m.nInputs(fName)
        @for(inName<- m.fmuInNames(fName)) {
        const int @{m.fmuPortName(fName, inName)} := @m.fmuInputEncoding(fName)(inName);
        }
        // @fName outputs - @m.nOutputs(fName)
        @for(outName<- m.fmuOutNames(fName)) {
        const int @{m.fmuPortName(fName, outName)} := @m.fmuOutputEncoding(fName)(outName);
        }
        const int @{fName}_inputTypes[MaxNInputs] := { @m.fmuInputTypes(fName) };
        }

        //This array is to keep track of the value of each output port - each output port needs two variables (current and future)
        // and each variable is having two values (defined and time)
        variable connectionVariable[nFMU][MaxNOutputs][2] = { @m.connectionVariable };

        //Connections - do not longer contain the type of the input - but it is still a 1:1 mapping
        const ExternalConnection external[nExternal] = { @m.external };

        const InternalConnection feedthroughInStep[nInternal] = { @m.feedthroughInStep };

        //The initial internal connection could be different from the connection in the simulation and should be represented differently
        const InternalConnection feedthroughInInit[nInternalInit] = { @m.feedthroughInInit };

        //The array show if an FMU can reject a step or not - if the FMU can reject a step the value is 1 on the index defined by the fmus
        const bool mayRejectStep[nFMU] = { @m.mayRejectStep };

        //Numbers of operations in each step
        const int nInstantiationOperations := @m.nInstantiationOperations;
        const int nInitializationOperations := @m.nInitializationOperations;
        const int nStepOperations := @m.nStepOperations;
        const int nTerminationOperations := @m.nTerminationOperations;

        // Numbers for algebraic loop operations in init
        const int maxNAlgebraicLoopOperationsInInit := @m.maxNAlgebraicLoopOperationsInInit;
        const int maxNConvergeOperationsForAlgebraicLoopsInInit := @m.maxNConvergeOperationsForAlgebraicLoopsInInit;

        //Numbers of operations to be performed per algebraic loop in init
        const int[0,maxNConvergeOperationsForAlgebraicLoopsInInit] nConvergencePortsPerAlgebraicLoopInInit[nAlgebraicLoopsInInit] = {@m.nConvergencePortsPerAlgebraicLoopInInit};
        const int[0,maxNAlgebraicLoopOperationsInInit] nOperationsPerAlgebraicLoopInInit[nAlgebraicLoopsInInit] = {@m.nOperationsPerAlgebraicLoopInInit};


        // Number of operations in the step finding loop
        const int nFindStepOperations := @m.nFindStepOperations;
        const int nRestore := @m.nRestore;

        // Numbers for algebraic loop operations in step
        const int maxNAlgebraicLoopOperationsInStep := @m.maxNAlgebraicLoopOperationsInStep;
        const int maxNRetryOperationsForAlgebraicLoopsInStep := @m.maxNRetryOperationsForAlgebraicLoopsInStep;
        const int maxNConvergeOperationsForAlgebraicLoopsInStep := @m.maxNConvergeOperationsForAlgebraicLoopsInStep;

        //Numbers of operations to be performed per algebraic loop in step
        const int[0,maxNConvergeOperationsForAlgebraicLoopsInStep] nConvergencePortsPerAlgebraicLoopInStep[nAlgebraicLoopsInStep] = {@m.nConvergencePortsPerAlgebraicLoopInStep};
        const int[0,maxNAlgebraicLoopOperationsInStep] nOperationsPerAlgebraicLoopInStep[nAlgebraicLoopsInStep] = {@m.nOperationsPerAlgebraicLoopInStep};
        const int[0,maxNRetryOperationsForAlgebraicLoopsInStep] nRetryOperationsPerAlgebraicLoopInStep[nAlgebraicLoopsInStep] = {@m.nRetryOperationsPerAlgebraicLoopInStep};

        //These operations define what should be performed in the simulation - it is assumed that the operation first loads the fmus
        const Operation instantiationOperations[nInstantiationOperations] = { @m.instantiationOperations };

        const Operation initializationOperations[nInitializationOperations] = { @m.initializationOperations };

        const Operation stepOperations[nStepOperations] = { @m.stepOperations };

        //These are the operations to be performed in order to find the correct step
        //In these operation there is a difference on the third parameter to doStep:
        // H (A step-value greater than the allowed step (Greater than the number of FMUS)) means that we should look at the variable h
        // A stepSize (0:(nFMU-1)) means that the should look at that index in stepVariables use that as the step
        //This is being done inside - findStepAction

        const Operation findStepIteration[nFindStepOperations] = { @m.findStepLoopOperations };
        const Operation StepFix[nRestore] = { @m.findStepLoopRestoreOperations };

        //Possible multiple loops
        //Loop operations are to solve algebraic loops in the co-simulation scenario
        const Operation operationsPerAlgebraicLoopInStep[nAlgebraicLoopsInStep][maxNAlgebraicLoopOperationsInStep] = {@m.operationsPerAlgebraicLoopInStep };
        const Operation operationsPerAlgebraicLoopInInit[nAlgebraicLoopsInInit][maxNAlgebraicLoopOperationsInInit] = {@m.operationsPerAlgebraicLoopInInit };

        //The converge ports is to mark which variables that needs to be checked in the convergence loop
        //The convention is now to specify the FMU first and the port to denote the variables that should be checked
        const FmuOutputPort convergencePortsPerAlgebraicLoopInStep[nAlgebraicLoopsInStep][maxNConvergeOperationsForAlgebraicLoopsInStep] = {@m.convergencePortsPerAlgebraicLoopInStep };
        const FmuOutputPort convergencePortsPerAlgebraicLoopInInit[nAlgebraicLoopsInInit][maxNConvergeOperationsForAlgebraicLoopsInInit] = {@m.convergencePortsPerAlgebraicLoopInInit };

        const Operation retryOperationsPerAlgebraicLoopInStep[nAlgebraicLoopsInStep][maxNRetryOperationsForAlgebraicLoopsInStep] = {@m.retryOperationsPerAlgebraicLoopInStep };

        const Operation terminationOperations[nTerminationOperations] = { @m.terminationOperations };

    </declaration>
    <template>
        <name>Interpreter</name>
        <declaration>
            int inst_pc := 0;
            int init_pc := 0;
            int cosimstep_pc := 0;
            int terminate_pc := 0;
            int n := 0;

            void selectNextInstAction(){
            unpackOperation(instantiationOperations[inst_pc]);
            //Proceed to next action
            inst_pc++;
            }

            void selectNextInitAction(){
            unpackOperation(initializationOperations[init_pc]);
            //Proceed to next action
            init_pc++;
            }


            void selectNextCosimStepAction(){
            if(cosimstep_pc &lt; nStepOperations){
            unpackOperation(stepOperations[cosimstep_pc]);
            }
            //Proceed to next action
            cosimstep_pc++;
            }

            void findFMUTerminateAction(){
            unpackOperation(terminationOperations[terminate_pc]);
            //Proceed to next action
            terminate_pc++;
            }

            void takeStep(int global_h){
            //h is progression of time
            time := time + h;
            //Reset the loop actions
            cosimstep_pc := 0;
            //reset the global stepsize
            h := global_h;
            //reset n
            n := 0;
            }

            void setStepsizeFMU(int fmu, int fmu_step_size){
            if(mayRejectStep[fmu]){
            //If an FMU can reject a Step it is maximum step should be updated in each iteration
            stepVariables[fmu] = fmu_step_size;
            }else{
            //If not just set its maximum step to the global step
            stepVariables[fmu] = h;
            }
            n++;
            }
        </declaration>
        <location id="id7" x="569" y="34">
        </location>
        <location id="id8" x="1113" y="-102">
            <committed/>
        </location>
        <location id="id9" x="841" y="-102">
        </location>
        <location id="id10" x="2176" y="-127">
            <name x="2227" y="-152">Error</name>
        </location>
        <location id="id11" x="2048" y="25">
            <name x="1988" y="68">SolveAlgebraicLoop</name>
        </location>
        <location id="id12" x="2065" y="-221">
            <name x="2055" y="-255">FindStep</name>
        </location>
        <location id="id13" x="1351" y="-102">
            <name x="1325" y="-144">CosimStep</name>
            <committed/>
        </location>
        <location id="id14" x="1521" y="-425">
            <name x="1427" y="-484">NormalFMUAction</name>
        </location>
        <location id="id15" x="561" y="416">
            <name x="578" y="408">Terminated</name>
        </location>
        <location id="id16" x="561" y="272">
            <committed/>
        </location>
        <location id="id17" x="952" y="272">
            <name x="944" y="306">Termination</name>
            <committed/>
        </location>
        <location id="id18" x="1674" y="-102">
            <name x="1691" y="-68">Simulate</name>
            <committed/>
        </location>
        <location id="id19" x="569" y="-102">
            <committed/>
        </location>
        <location id="id20" x="339" y="-102">
            <name x="501" y="-357">Initialization</name>
            <committed/>
        </location>
        <location id="id21" x="-174" y="-102">
            <name x="-139" y="-340">instantiationOperations</name>
            <committed/>
        </location>
        <location id="id22" x="107" y="-102">
        </location>
        <location id="id23" x="-459" y="-102">
            <name x="-469" y="-136">Start</name>
            <committed/>
        </location>
        <init ref="id23"/>
        <transition>
            <source ref="id7"/>
            <target ref="id19"/>
            <label kind="synchronisation" x="654" y="-34">solveLoopInit?</label>
            <nail x="646" y="-34"/>
        </transition>
        <transition>
            <source ref="id19"/>
            <target ref="id7"/>
            <label kind="guard" x="382" y="-17">action == loop</label>
            <label kind="synchronisation" x="408" y="-59">solveLoopInit!</label>
            <nail x="493" y="-25"/>
        </transition>
        <transition>
            <source ref="id8"/>
            <target ref="id8"/>
            <label kind="select" x="1020" y="-306">step_fmu:int[1,H_max]</label>
            <label kind="guard" x="1037" y="-289">n &lt; nFMU</label>
            <label kind="assignment" x="1011" y="-272">setStepsizeFMU(n, step_fmu)</label>
            <nail x="1003" y="-246"/>
            <nail x="1198" y="-246"/>
        </transition>
        <transition>
            <source ref="id8"/>
            <target ref="id13"/>
            <label kind="guard" x="1181" y="-136">n == nFMU</label>
        </transition>
        <transition>
            <source ref="id18"/>
            <target ref="id8"/>
            <label kind="select" x="1377" y="51">global_h:int[1,H_max]</label>
            <label kind="guard" x="1079" y="34">cosimstep_pc == nStepOperations + 1
                &amp;&amp; time &lt; end
            </label>
            <label kind="assignment" x="1470" y="17">takeStep(global_h), isSimulation= 0</label>
            <nail x="1351" y="34"/>
        </transition>
        <transition>
            <source ref="id9"/>
            <target ref="id8"/>
            <label kind="guard" x="859" y="-136">init_pc == nInitializationOperations</label>
            <label kind="synchronisation" x="859" y="-119">actionPerformed?</label>
            <label kind="assignment" x="858" y="-85">isInit = 0</label>
        </transition>
        <transition>
            <source ref="id9"/>
            <target ref="id19"/>
            <label kind="guard" x="586" y="-314">init_pc &lt; nInitializationOperations</label>
            <label kind="synchronisation" x="587" y="-297">actionPerformed?</label>
            <label kind="assignment" x="586" y="-280">selectNextInitAction()</label>
            <nail x="841" y="-280"/>
            <nail x="569" y="-280"/>
        </transition>
        <transition>
            <source ref="id19"/>
            <target ref="id9"/>
            <label kind="guard" x="603" y="-204">action == get ||
                action == set ||
                action == exitInitialization ||
                action == enterInitialization
            </label>
            <label kind="synchronisation" x="587" y="-123">fmu[activeFMU]!</label>
        </transition>
        <transition>
            <source ref="id20"/>
            <target ref="id19"/>
            <label kind="assignment" x="357" y="-102">selectNextInitAction(), isInit = 1</label>
        </transition>
        <transition>
            <source ref="id22"/>
            <target ref="id20"/>
            <label kind="guard" x="127" y="-136">inst_pc == nInstantiationOperations</label>
            <label kind="synchronisation" x="135" y="-119">actionPerformed?</label>
        </transition>
        <transition>
            <source ref="id11"/>
            <target ref="id10"/>
            <label kind="synchronisation" x="1980" y="-17">ErrorChan?</label>
            <nail x="2176" y="25"/>
        </transition>
        <transition>
            <source ref="id12"/>
            <target ref="id10"/>
            <label kind="synchronisation" x="2065" y="-255">ErrorChan?</label>
            <nail x="2176" y="-221"/>
        </transition>
        <transition>
            <source ref="id11"/>
            <target ref="id18"/>
            <label kind="synchronisation" x="1784" y="-26">solveLoop?</label>
            <label kind="assignment" x="1801" y="8">selectNextCosimStepAction()</label>
        </transition>
        <transition>
            <source ref="id18"/>
            <target ref="id11"/>
            <label kind="guard" x="1903" y="-93">loopActive != -1
                &amp;&amp; action == loop
            </label>
            <label kind="synchronisation" x="1818" y="-127">solveLoop!</label>
            <nail x="2065" y="-110"/>
        </transition>
        <transition>
            <source ref="id12"/>
            <target ref="id18"/>
            <label kind="synchronisation" x="1861" y="-416">findStepChan?</label>
            <label kind="assignment" x="1861" y="-391">selectNextCosimStepAction(),
                stepFinderActive := false
            </label>
            <nail x="1946" y="-365"/>
        </transition>
        <transition>
            <source ref="id18"/>
            <target ref="id12"/>
            <label kind="guard" x="1844" y="-221">action == findStep</label>
            <label kind="synchronisation" x="2005" y="-170">findStepChan!</label>
            <label kind="assignment" x="1997" y="-195">stepFinderActive := true</label>
        </transition>
        <transition>
            <source ref="id13"/>
            <target ref="id18"/>
            <label kind="assignment" x="1428" y="-144">selectNextCosimStepAction(), isSimulation = 1</label>
            <nail x="1521" y="-102"/>
        </transition>
        <transition>
            <source ref="id15"/>
            <target ref="id15"/>
            <nail x="442" y="476"/>
            <nail x="442" y="391"/>
        </transition>
        <transition>
            <source ref="id14"/>
            <target ref="id18"/>
            <label kind="synchronisation" x="1631" y="-493">actionPerformed?</label>
            <label kind="assignment" x="1631" y="-467">selectNextCosimStepAction()</label>
            <nail x="1716" y="-442"/>
        </transition>
        <transition>
            <source ref="id18"/>
            <target ref="id14"/>
            <label kind="guard" x="1334" y="-382">(action == get ||
                action == set ||
                action == step ||
                action == save ||
                action == restore)
                &amp;&amp; cosimstep_pc &lt; (nStepOperations +1)
            </label>
            <label kind="synchronisation" x="1470" y="-255">fmu[activeFMU]!</label>
        </transition>
        <transition>
            <source ref="id16"/>
            <target ref="id17"/>
            <label kind="guard" x="578" y="120">terminate_pc &lt; nTerminationOperations</label>
            <label kind="assignment" x="680" y="86">findFMUTerminateAction()</label>
            <nail x="561" y="153"/>
            <nail x="952" y="153"/>
        </transition>
        <transition>
            <source ref="id16"/>
            <target ref="id15"/>
            <label kind="guard" x="570" y="332">terminate_pc == nTerminationOperations</label>
        </transition>
        <transition>
            <source ref="id17"/>
            <target ref="id16"/>
            <label kind="guard" x="655" y="187">action == unload ||
                action == freeInstance ||
                action == terminate
            </label>
            <label kind="synchronisation" x="697" y="247">fmu[activeFMU]!</label>
        </transition>
        <transition>
            <source ref="id18"/>
            <target ref="id17"/>
            <label kind="guard" x="1436" y="102">cosimstep_pc == nStepOperations + 1
                &amp;&amp; time &gt;= end
            </label>
            <label kind="assignment" x="1436" y="161">findFMUTerminateAction(), isSimulation = 0</label>
            <nail x="1683" y="272"/>
        </transition>
        <transition>
            <source ref="id21"/>
            <target ref="id22"/>
            <label kind="guard" x="-120" y="-93">action == instantiate ||
                action == setParameter ||
                action == setupExperiment
            </label>
            <label kind="synchronisation" x="-106" y="-127">fmu[activeFMU]!</label>
        </transition>
        <transition>
            <source ref="id22"/>
            <target ref="id21"/>
            <label kind="guard" x="-156" y="-297">inst_pc &lt; nInstantiationOperations</label>
            <label kind="synchronisation" x="-156" y="-280">actionPerformed?</label>
            <label kind="assignment" x="-127" y="-263">selectNextInstAction()</label>
            <nail x="107" y="-263"/>
            <nail x="-174" y="-263"/>
        </transition>
        <transition>
            <source ref="id23"/>
            <target ref="id21"/>
            <label kind="assignment" x="-383" y="-102">selectNextInstAction()</label>
        </transition>
    </template>
    <template>
        <name>LoopSolverInit</name>
        <parameter>const int maxIteration</parameter>
        <declaration>
            int convergence_pc := 0;

            //Number of iteration run in the loop Solver
            int currentIteration := 0;

            //for index
            int i := 0;

            void selectNextLoopAction(int l){
                unpackOperation(operationsPerAlgebraicLoopInInit[l][convergence_pc]);
                //Proceed to next action
                convergence_pc ++;
            }

            void updateConvergenceVariables(int l){
                int fmu;
                int v;
                for(i = 0; i &lt; nConvergencePortsPerAlgebraicLoopInInit[l]; i++){
                    fmu = convergencePortsPerAlgebraicLoopInInit[l][i].FMU;
                    v = convergencePortsPerAlgebraicLoopInInit[l][i].port;
                    connectionVariable[fmu][v][tentative].status = connectionVariable[fmu][v][final].status;
                    connectionVariable[fmu][v][tentative].time = connectionVariable[fmu][v][final].time;
                }
            }

            void loopConverge(){
                //Loop not longer active
                loopActive := -1;
                //Loop action counter reset
                convergence_pc := 0;
                //Reset convergence counter
                currentIteration := 0;
            }


            void resetConvergenceloop(){
                convergence_pc := 0;
                selectNextLoopAction(loopActive);
            }

            //Convergence will happen when all convergenceVariables have a similar future and current value
            bool convergenceCriteria(int l){
                return forall(x:int[0,maxNConvergeOperationsForAlgebraicLoopsInInit-1])
                                    convergencePortsPerAlgebraicLoopInInit[l][x].FMU != noFMU imply connectionVariable[convergencePortsPerAlgebraicLoopInInit[l][x].FMU][convergencePortsPerAlgebraicLoopInInit[l][x].port][final].status
                                == connectionVariable[convergencePortsPerAlgebraicLoopInInit[l][x].FMU][convergencePortsPerAlgebraicLoopInInit[l][x].port][tentative].status
                                &amp;&amp;
                                connectionVariable[convergencePortsPerAlgebraicLoopInInit[l][x].FMU][convergencePortsPerAlgebraicLoopInInit[l][x].port][final].time
                                == connectionVariable[convergencePortsPerAlgebraicLoopInInit[l][x].FMU][convergencePortsPerAlgebraicLoopInInit[l][x].port][tentative].time;
            }

            bool convergence(int l){
                return (convergenceCriteria(l) &amp;&amp; isLoopExtraIteration);
            }


            void updateIsExtra(int l){
                if(convergenceCriteria(l)){
                    isLoopExtraIteration := true;
                }
            }
        </declaration>
        <location id="id0" x="-1011" y="-518">
            <committed/>
        </location>
        <location id="id1" x="-94" y="-816">
            <name x="-146" y="-850">NotConverging</name>
        </location>
        <location id="id2" x="-391" y="-247">
            <name x="-340" y="-213">UpdateVariables</name>
            <committed/>
        </location>
        <location id="id3" x="-391" y="-510">
            <name x="-357" y="-519">CheckConvergence</name>
            <committed/>
        </location>
        <location id="id4" x="-1173" y="-416">
        </location>
        <location id="id5" x="-1343" y="-518">
            <committed/>
        </location>
        <location id="id6" x="-1708" y="-518">
        </location>
        <init ref="id6"/>
        <transition>
            <source ref="id3"/>
            <target ref="id2"/>
            <label kind="guard" x="-391" y="-417">!convergence(loopActive) &amp;&amp;
                currentIteration &lt; maxIteration
            </label>
            <label kind="assignment" x="-374" y="-349">updateIsExtra(loopActive)</label>
        </transition>
        <transition>
            <source ref="id0"/>
            <target ref="id5"/>
            <label kind="guard" x="-1368" y="-671">convergence_pc &lt; nOperationsPerAlgebraicLoopInInit[loopActive]
            </label>
            <label kind="assignment" x="-1283" y="-510">selectNextLoopAction(loopActive)</label>
            <nail x="-1173" y="-620"/>
        </transition>
        <transition>
            <source ref="id0"/>
            <target ref="id3"/>
            <label kind="guard" x="-884" y="-569">convergence_pc == nOperationsPerAlgebraicLoopInInit[loopActive]
            </label>
            <label kind="assignment" x="-993" y="-518">currentIteration++</label>
        </transition>
        <transition>
            <source ref="id4"/>
            <target ref="id0"/>
            <label kind="synchronisation" x="-1020" y="-433">actionPerformed?</label>
        </transition>
        <transition>
            <source ref="id5"/>
            <target ref="id4"/>
            <label kind="guard" x="-1249" y="-374">action == get ||
                action == set
            </label>
            <label kind="synchronisation" x="-1282" y="-403">fmu[activeFMU]!</label>
        </transition>
        <transition>
            <source ref="id2"/>
            <target ref="id5"/>
            <label kind="assignment" x="-1402" y="-212">updateConvergenceVariables(loopActive),
                resetConvergenceloop()
            </label>
            <nail x="-1309" y="-246"/>
            <nail x="-1343" y="-246"/>
        </transition>
        <transition>
            <source ref="id3"/>
            <target ref="id1"/>
            <label kind="guard" x="-468" y="-859">!convergence(loopActive) &amp;&amp;
                currentIteration == maxIteration
            </label>
            <label kind="synchronisation" x="-298" y="-884">ErrorChan!</label>
            <nail x="-323" y="-620"/>
            <nail x="-323" y="-816"/>
        </transition>
        <transition>
            <source ref="id3"/>
            <target ref="id6"/>
            <label kind="guard" x="-1249" y="-816">convergence(loopActive)</label>
            <label kind="synchronisation" x="-1071" y="-816">solveLoopInit!</label>
            <label kind="assignment" x="-1385" y="-859">loopConverge(),
                isLoopExtraIteration:= false
            </label>
            <nail x="-391" y="-782"/>
            <nail x="-1105" y="-790"/>
            <nail x="-1708" y="-790"/>
        </transition>
        <transition>
            <source ref="id6"/>
            <target ref="id5"/>
            <label kind="guard" x="-1581" y="-569">loopActive != -1
                &amp;&amp; action == loop
            </label>
            <label kind="synchronisation" x="-1505" y="-536">solveLoopInit?</label>
            <label kind="assignment" x="-1632" y="-493">selectNextLoopAction(loopActive),
                currentIteration := 0
            </label>
            <nail x="-1377" y="-518"/>
        </transition>
    </template>
    <template>
        <name>LoopSolver</name>
        <parameter>const int maxIteration</parameter>
        <declaration>
            int convergence_pc := 0;
            int restore_pc := 0;

            //Number of iteration run in the loop Solver
            int currentConvergeLoopIteration := 0;

            //for index
            int i := 0;

            void selectNextLoopAction(int l){
                unpackOperation(operationsPerAlgebraicLoopInStep[l][convergence_pc]);
                //Proceed to next action
                convergence_pc ++;
            }

            void selectNextRestoreAction(int l){
                unpackOperation(retryOperationsPerAlgebraicLoopInStep[l][restore_pc]);
                restore_pc++;
            }


            void updateConvergenceVariables(int l){
                int fmu;
                int v;
                for(i = 0; i &lt; nConvergencePortsPerAlgebraicLoopInStep[l]; i++){
                    fmu = convergencePortsPerAlgebraicLoopInStep[l][i].FMU;
                    v = convergencePortsPerAlgebraicLoopInStep[l][i].port;
                    connectionVariable[fmu][v][final].status := connectionVariable[fmu][v][tentative].status;
                    connectionVariable[fmu][v][final].time := connectionVariable[fmu][v][tentative].time;
                }
            }

            void loopConverge(){
                //Loop not longer active
                loopActive := -1;
                //Loop action counter reset
                convergence_pc := 0;
                //Reset convergence counter
                currentConvergeLoopIteration := 0;
            }


            void resetConvergenceloop(){
                convergence_pc := 0;
                restore_pc := 0;
                selectNextLoopAction(loopActive);
            }

            //Convergence will happen when all convergenceVariables have a similar future and current value
            bool convergenceCriteria(int l){
            return forall(x:int[0,maxNConvergeOperationsForAlgebraicLoopsInStep-1])
                convergencePortsPerAlgebraicLoopInStep[l][x].FMU != noFMU imply
                connectionVariable[convergencePortsPerAlgebraicLoopInStep[l][x].FMU][convergencePortsPerAlgebraicLoopInStep[l][x].port][final].status
                ==
                connectionVariable[convergencePortsPerAlgebraicLoopInStep[l][x].FMU][convergencePortsPerAlgebraicLoopInStep[l][x].port][tentative].status
                &amp;&amp;
                connectionVariable[convergencePortsPerAlgebraicLoopInStep[l][x].FMU][convergencePortsPerAlgebraicLoopInStep[l][x].port][final].time
                ==
                connectionVariable[convergencePortsPerAlgebraicLoopInStep[l][x].FMU][convergencePortsPerAlgebraicLoopInStep[l][x].port][tentative].time;
            }

            bool convergence(int l){
                return (convergenceCriteria(l) &amp;&amp; isLoopExtraIteration);
            }


            void updateIsExtra(int l){
                if(convergenceCriteria(l)){
                    isLoopExtraIteration := true;
                }
            }
        </declaration>
        <location id="id15" x="-1011" y="-518">
            <committed/>
        </location>
        <location id="id16" x="-1079" y="-663">
        </location>
        <location id="id17" x="-442" y="-824">
            <name x="-494" y="-858">NotConverging</name>
        </location>
        <location id="id18" x="-484" y="-255">
            <name x="-433" y="-221">UpdateVariables</name>
            <committed/>
        </location>
        <location id="id19" x="-17" y="-518">
        </location>
        <location id="id20" x="-340" y="-518">
            <name x="-332" y="-509">RestoreState</name>
            <committed/>
        </location>
        <location id="id21" x="-739" y="-518">
            <name x="-714" y="-543">CheckConvergence</name>
            <committed/>
        </location>
        <location id="id22" x="-1088" y="-357">
        </location>
        <location id="id23" x="-1343" y="-518">
            <committed/>
        </location>
        <location id="id24" x="-1708" y="-518">
        </location>
        <init ref="id24"/>
        <transition>
            <source ref="id15"/>
            <target ref="id23"/>
            <label kind="guard" x="-1291" y="-548">convergence_pc &lt; nOperationsPerAlgebraicLoopInStep[loopActive]
            </label>
            <label kind="assignment" x="-1283" y="-510">selectNextLoopAction(loopActive)</label>
        </transition>
        <transition>
            <source ref="id23"/>
            <target ref="id16"/>
            <label kind="guard" x="-1292" y="-646">action == findStep</label>
            <label kind="synchronisation" x="-1317" y="-612">findStepChan!</label>
            <label kind="assignment" x="-1334" y="-680">isStepNested := true</label>
        </transition>
        <transition>
            <source ref="id15"/>
            <target ref="id21"/>
            <label kind="guard" x="-1011" y="-552">convergence_pc == nOperationsPerAlgebraicLoopInStep[loopActive]
            </label>
            <label kind="assignment" x="-993" y="-518">currentConvergeLoopIteration++</label>
        </transition>
        <transition>
            <source ref="id16"/>
            <target ref="id15"/>
            <label kind="synchronisation" x="-1011" y="-612">findStepChan?</label>
            <label kind="assignment" x="-1020" y="-586">isStepNested = false</label>
        </transition>
        <transition>
            <source ref="id22"/>
            <target ref="id15"/>
            <label kind="synchronisation" x="-1020" y="-433">actionPerformed?</label>
        </transition>
        <transition>
            <source ref="id23"/>
            <target ref="id22"/>
            <label kind="guard" x="-1249" y="-374">action == get ||
                action == set ||
                action == step ||
                action == restore
            </label>
            <label kind="synchronisation" x="-1282" y="-403">fmu[activeFMU]!</label>
        </transition>
        <transition>
            <source ref="id18"/>
            <target ref="id23"/>
            <label kind="assignment" x="-1402" y="-212">updateConvergenceVariables(loopActive),
                resetConvergenceloop()
            </label>
            <nail x="-1309" y="-246"/>
            <nail x="-1343" y="-246"/>
        </transition>
        <transition>
            <source ref="id21"/>
            <target ref="id17"/>
            <label kind="guard" x="-816" y="-867">!convergence(loopActive) &amp;&amp;
                currentConvergeLoopIteration == maxIteration
            </label>
            <label kind="synchronisation" x="-646" y="-892">ErrorChan!</label>
            <nail x="-671" y="-628"/>
            <nail x="-671" y="-824"/>
        </transition>
        <transition>
            <source ref="id19"/>
            <target ref="id18"/>
            <label kind="guard" x="-229" y="-306">restore_pc == nRetryOperationsPerAlgebraicLoopInStep[loopActive]
            </label>
            <label kind="synchronisation" x="-221" y="-280">actionPerformed?</label>
            <nail x="-17" y="-255"/>
        </transition>
        <transition>
            <source ref="id19"/>
            <target ref="id20"/>
            <label kind="guard" x="-272" y="-731">restore_pc &lt; nRetryOperationsPerAlgebraicLoopInStep[loopActive]
            </label>
            <label kind="synchronisation" x="-272" y="-705">actionPerformed?</label>
            <label kind="assignment" x="-297" y="-663">selectNextRestoreAction(loopActive)</label>
            <nail x="-17" y="-680"/>
            <nail x="-340" y="-680"/>
        </transition>
        <transition>
            <source ref="id20"/>
            <target ref="id19"/>
            <label kind="synchronisation" x="-247" y="-552">fmu[activeFMU]!</label>
            <nail x="-213" y="-518"/>
        </transition>
        <transition>
            <source ref="id21"/>
            <target ref="id24"/>
            <label kind="guard" x="-1249" y="-816">convergence(loopActive)</label>
            <label kind="synchronisation" x="-1071" y="-816">solveLoop!</label>
            <label kind="assignment" x="-1385" y="-859">loopConverge(),
                isLoopExtraIteration:= false
            </label>
            <nail x="-739" y="-790"/>
            <nail x="-1105" y="-790"/>
            <nail x="-1708" y="-790"/>
        </transition>
        <transition>
            <source ref="id21"/>
            <target ref="id20"/>
            <label kind="guard" x="-671" y="-586">!convergence(loopActive) &amp;&amp;
                currentConvergeLoopIteration &lt; maxIteration
            </label>
            <label kind="assignment" x="-663" y="-510">selectNextRestoreAction(loopActive),
                updateIsExtra(loopActive)
            </label>
        </transition>
        <transition>
            <source ref="id24"/>
            <target ref="id23"/>
            <label kind="guard" x="-1581" y="-569">loopActive != -1
                &amp;&amp; action == loop
            </label>
            <label kind="synchronisation" x="-1505" y="-536">solveLoop?</label>
            <label kind="assignment" x="-1632" y="-493">selectNextLoopAction(loopActive),
                currentConvergeLoopIteration := 0
            </label>
            <nail x="-1377" y="-518"/>
        </transition>
    </template>
    <template>
        <name>StepFinder</name>
        <parameter>const int maxTries</parameter>
        <declaration>
            int step_pc := 0;
            int restore_pc := 0;
            int numbersOfTries := 0;

            void selectNextStepFinderAction(){
                unpackOperation(findStepIteration[step_pc]);
                step_pc++;
            }

            void selectNextStepRestoreAction(){
                unpackOperation(StepFix[restore_pc]);
                restore_pc++;
            }

            void findMinStep(){
            //Maximum step size allowed
                int min = nFMU;
                int j := 0;
                for(j = 0; j &lt; nFMU; j++){
                    if(stepVariables[j] &lt; min){
                        min := stepVariables[j];
                    }
                }
                h := min;
            }


            bool stepFound(){
                //All FMU that may reject a step should be able to take the same step - h
                return forall(x:int[0, nFMU-1]) mayRejectStep[x] imply stepVariables[x] == h;
            }

            bool loopConverged(){
                return (stepFound() &amp;&amp; isStepExtraIteration);
            }


            void updateIsExtra(){
                if(stepFound()){
                    isStepExtraIteration := true;
                    //Reset numbers of tries to 0 - This is to avoid problems with the maximum number of tries and not to active the nested checks
                    numbersOfTries := 0;
                }
            }
        </declaration>
        <location id="id26" x="1122" y="-178">
            <committed/>
        </location>
        <location id="id27" x="-34" y="-178">
            <committed/>
        </location>
        <location id="id28" x="-144" y="17">
        </location>
        <location id="id29" x="817" y="144">
            <committed/>
        </location>
        <location id="id30" x="654" y="-578">
            <name x="644" y="-612">NoCommonStep</name>
        </location>
        <location id="id31" x="-1427" y="-178">
            <name x="-1478" y="-187">Start</name>
        </location>
        <location id="id32" x="1011" y="-331">
        </location>
        <location id="id33" x="732" y="-178">
            <name x="681" y="-237">Reset</name>
            <committed/>
        </location>
        <location id="id34" x="348" y="-178">
            <committed/>
        </location>
        <location id="id35" x="-144" y="-382">
        </location>
        <location id="id36" x="-510" y="-178">
            <committed/>
        </location>
        <init ref="id31"/>
        <transition>
            <source ref="id31"/>
            <target ref="id36"/>
            <label kind="synchronisation" x="-1105" y="-212">findStepChan?</label>
            <label kind="assignment" x="-1156" y="-161">selectNextStepFinderAction()</label>
        </transition>
        <transition>
            <source ref="id26"/>
            <target ref="id29"/>
            <label kind="guard" x="884" y="110">nRestore == restore_pc</label>
            <nail x="1147" y="-178"/>
            <nail x="1147" y="144"/>
        </transition>
        <transition>
            <source ref="id26"/>
            <target ref="id33"/>
            <label kind="guard" x="892" y="-212">restore_pc &lt; nRestore</label>
            <label kind="assignment" x="901" y="-170">selectNextStepRestoreAction()</label>
        </transition>
        <transition>
            <source ref="id32"/>
            <target ref="id26"/>
            <label kind="synchronisation" x="1062" y="-289">actionPerformed?</label>
        </transition>
        <transition>
            <source ref="id27"/>
            <target ref="id36"/>
            <label kind="guard" x="-365" y="-212">step_pc &lt; nFindStepOperations</label>
            <label kind="assignment" x="-416" y="-178">selectNextStepFinderAction()</label>
        </transition>
        <transition>
            <source ref="id28"/>
            <target ref="id27"/>
            <label kind="synchronisation" x="-51" y="-85">solveLoop?</label>
            <label kind="assignment" x="-102" y="-51">isLoopNested := false</label>
        </transition>
        <transition>
            <source ref="id27"/>
            <target ref="id34"/>
            <label kind="guard" x="-16" y="-212">nFindStepOperations == step_pc</label>
            <label kind="assignment" x="110" y="-161">findMinStep(),
                numbersOfTries++
            </label>
        </transition>
        <transition>
            <source ref="id35"/>
            <target ref="id27"/>
            <label kind="synchronisation" x="-85" y="-323">actionPerformed?</label>
        </transition>
        <transition>
            <source ref="id36"/>
            <target ref="id28"/>
            <label kind="guard" x="-459" y="-51">action == loop</label>
            <label kind="synchronisation" x="-459" y="-76">solveLoop!</label>
            <label kind="assignment" x="-442" y="8">isLoopNested := true</label>
        </transition>
        <transition>
            <source ref="id29"/>
            <target ref="id36"/>
            <label kind="assignment" x="-459" y="170">step_pc := 0, restore_pc := 0, selectNextStepFinderAction()
            </label>
            <nail x="-510" y="153"/>
        </transition>
        <transition>
            <source ref="id34"/>
            <target ref="id30"/>
            <label kind="guard" x="407" y="-561">!stepFound() &amp;&amp;
                numbersOfTries == maxTries
            </label>
            <label kind="synchronisation" x="484" y="-510">ErrorChan!</label>
        </transition>
        <transition>
            <source ref="id34"/>
            <target ref="id31"/>
            <label kind="guard" x="-1258" y="-748">loopConverged()</label>
            <label kind="synchronisation" x="-1258" y="-722">findStepChan!</label>
            <label kind="assignment" x="-1258" y="-688">step_pc := 0, isStepExtraIteration := false, restore_pc:=0,
                numbersOfTries := 0
            </label>
            <nail x="76" y="-612"/>
            <nail x="-1428" y="-612"/>
        </transition>
        <transition>
            <source ref="id33"/>
            <target ref="id32"/>
            <label kind="synchronisation" x="782" y="-348">fmu[activeFMU]!</label>
        </transition>
        <transition>
            <source ref="id34"/>
            <target ref="id33"/>
            <label kind="guard" x="416" y="-221">!loopConverged() &amp;&amp;
                numbersOfTries &lt; maxTries
            </label>
            <label kind="assignment" x="433" y="-161">selectNextStepRestoreAction(),
                updateIsExtra()
            </label>
        </transition>
        <transition>
            <source ref="id36"/>
            <target ref="id35"/>
            <label kind="guard" x="-467" y="-382">action == get ||
                action == set ||
                action == step ||
                action == restore
            </label>
            <label kind="synchronisation" x="-484" y="-289">fmu[activeFMU]!</label>
        </transition>
    </template>
    <template>
        <name>FMU</name>
        <parameter>const int id, const int nOutput, const int nInput, const int inputType[MaxNInputs]</parameter>
        <declaration>
            int cTime := START_TIME;
            variable inputVariables[MaxNInputs] = { @{m.variableArray(m.maxNInputs)} };
            variable outputVariables[MaxNOutputs] = { @{m.variableArray(m.maxNOutputs)} };

            //Index for the for-loop
            int i := 0;

            //Backup state
            variable savedOutputVariables[MaxNOutputs];
            variable savedInputVariables[MaxNInputs];
            int savedTime;
            bool isSaved := false;
            bool isConsistent := true;

            int stepEnabled := false;
            bool getEnabled[MaxNOutputs] := { @m.getEnabled };
            bool setEnabled[MaxNInputs] := { @m.setEnabled };

            void initialize(){
                //Set all variables to undefined
                for(i = 0; i &lt; nInput; i++){
                    inputVariables[i].status := undefined;
                    inputVariables[i].time := 0;
                }
                for(i := 0; i &lt; nOutput; i++){
                    outputVariables[i].status := undefined;
                    outputVariables[i].time := 0;
                }
            }

            void getValue(int v, int a){
                outputVariables[v].status := defined;
                outputVariables[v].time := cTime;

                connectionVariable[id][v][a].status := defined;
                connectionVariable[id][v][a].time := cTime;
            }

            void setValue(int v, int a){
                inputVariables[v].status := defined;
                for(i = 0; i &lt; nExternal; i++){
                    if(external[i].TrgFMU == id &amp;&amp; external[i].input == v){
                        inputVariables[v].time := connectionVariable[external[i].SrcFMU][external[i].output][a].time;
                    }
                }
            }

            //Proceed in time - we will start by assuming an FMU can't reject a stepsize
            void doStep(int t){
                //Checking of step is valid
                if(t &gt; stepVariables[id]){
                    //Step is too big and will not be allowed - t is reset too the biggest allowed step
                    t := stepVariables[id];
                }

                //Take step
                cTime := cTime + t;

                isConsistent := true;

                for(i = 0; i &lt; nInput; i++){
                    if(inputVariables[i].time != cTime){
                        isConsistent := false;
                    }
                }

                //Reset outputs accesssed and advance their timestamp
                for(i = 0; i &lt; nOutput; i++){
                    //The inputs of the FMUs are inconsistent (not all are at time cTime) - so the FMUs output valid should be set to NaN
                    if(isConsistent){
                        outputVariables[i].status := undefined;
                        outputVariables[i].time := cTime;
                    }else{
                        outputVariables[i].status := notStable;
                        outputVariables[i].time := cTime;
                    }
                }

                isConsistent := true;

                //Update or return the taken step size
                stepVariables[id] := t;
            }

            void restoreState(){
                outputVariables := savedOutputVariables;
                inputVariables := savedInputVariables;
                cTime := savedTime;
            }

            void saveState(){
                savedOutputVariables := outputVariables;
                savedInputVariables := inputVariables;
                savedTime := cTime;
                isSaved := true;
            }

            bool preSetInit(int v, int a){
                if(shouldChecksBeDisabled()){
                    return true;
                }
                //All outputs connected to the input should be defined - no difference between delay and reactive in init. ConnectionVariables an d ExternalConnections are having the same order
                return forall(x:int[0, nExternal-1]) external[x].TrgFMU == id &amp;&amp; external[x].input == v imply
                    connectionVariable[external[x].SrcFMU][external[x].output][a].status == defined;

            }

            bool preGetInit(int v){
                if(shouldChecksBeDisabled()){
                    return true;
                }
                //The internal time should be equivalent to 0 and all variable connected to this one should be defined
                return forall(x:int[0, nInternalInit-1]) feedthroughInInit[x].FMU == id &amp;&amp; feedthroughInInit[x].output == v
                    imply inputVariables[feedthroughInInit[x].input].status == defined;
            }


            bool preSet(int v, int a){
                if(shouldChecksBeDisabled()){
                    return true;
                }

            //If the connection is reactive the connected variable needs to have a greater than the time of the FMU and be defined
            return (forall(x:int[0, nExternal-1]) external[x].TrgFMU == id &amp;&amp; external[x].input == v &amp;&amp;
                inputType[v] == reactive imply connectionVariable[external[x].SrcFMU][external[x].output][a].status == defined &amp;&amp;
                                connectionVariable[external[x].SrcFMU][external[x].output][a].time &gt; cTime) &amp;&amp;
                (forall(x:int[0, nExternal-1]) external[x].TrgFMU == id &amp;&amp; external[x].input == v &amp;&amp; inputType[v] == delayed
                imply connectionVariable[external[x].SrcFMU][external[x].output][a].status == defined &amp;&amp;
                connectionVariable[external[x].SrcFMU][external[x].output][a].time == cTime);
            }


            bool preGet(int v){
                if(shouldChecksBeDisabled()){
                    return true;
                }

                //All internal connections should be defined at time cTime
                return forall(x:int[0, nInternal-1]) feedthroughInStep[x].FMU == id &amp;&amp; feedthroughInStep[x].output == v
                imply inputVariables[feedthroughInStep[x].input].status == defined &amp;&amp; inputVariables[feedthroughInStep[x].input].time == cTime;
            }

            bool preDoStep(int t){
                if(shouldChecksBeDisabled()){
                    return true;
                }

                //All delayed input ports should be defined at the current time
                //And all reactive inputs ports should be defined at the next time step
                return (forall(x:int[0, MaxNInputs-1]) inputType[x] == reactive imply inputVariables[x].status == defined &amp;&amp; inputVariables[x].time == cTime + t) &amp;&amp;
                (forall(x:int[0, MaxNInputs-1]) inputType[x] == delayed imply inputVariables[x].status == defined &amp;&amp; inputVariables[x].time == cTime);
            }

            //An FMU can only enter the Simulation mode when all connected FMU variables are defined at time 0
            bool preSimulation(){
                return ((forall(x:int[0, MaxNOutputs-1]) outputVariables[x].status == defined &amp;&amp; outputVariables[x].time == 0)
                &amp;&amp; (forall(x:int[0, MaxNInputs-1]) inputVariables[x].status == defined &amp;&amp;
                inputVariables[x].time == 0));
            }

            bool preSaveState(){
                //Always possible
                return true;
            }

            bool preRestoreState(){
                //Should a requirement be a saved previous state?
                return isSaved;
            }

            void updateEnableActions(bool isInit){
                if(isInit){
                    for(i = 0; i &lt; nInput; i++){
                        setEnabled[i] := preSetInit(i, final) &amp;&amp;
                            inputVariables[i].status == undefined;
                    }
                    for(i := 0; i &lt; nOutput; i++){
                        getEnabled[i] := preGetInit(i) &amp;&amp;
                            outputVariables[i].status == undefined;
                    }
                stepEnabled := false;
            }else{
                    for(i = 0; i &lt; nInput; i++){
                        setEnabled[i] := preSet(i, final);
                    }
                    for(i := 0; i &lt; nOutput; i++){
                        getEnabled[i] := preGet(i);
                    }
                    stepEnabled := preDoStep(h);

                }
            }

        </declaration>
        <location id="id37" x="-9588" y="-11305">
            <name x="-9598" y="-11339">Unloaded</name>
        </location>
        <location id="id38" x="-9826" y="-11305">
        </location>
        <location id="id39" x="-11584" y="-11118">
        </location>
        <location id="id40" x="-12034" y="-11118">
            <committed/>
        </location>
        <location id="id41" x="-10752" y="-11305">
            <label kind="invariant" x="-10795" y="-11280">preSimulation()</label>
            <committed/>
        </location>
        <location id="id42" x="-11339" y="-11305">
            <committed/>
        </location>
        <location id="id43" x="-11813" y="-11305">
            <committed/>
        </location>
        <location id="id44" x="-12230" y="-11305">
            <committed/>
        </location>
        <location id="id45" x="-11584" y="-11305">
        </location>
        <location id="id46" x="-12034" y="-11305">
            <name x="-12204" y="-11543">Instantiated</name>
        </location>
        <location id="id47" x="-10574" y="-11152">
            <label kind="invariant" x="-10584" y="-11135">preRestoreState()</label>
            <committed/>
        </location>
        <location id="id48" x="-11058" y="-11186">
            <label kind="invariant" x="-11101" y="-11169">preGetInit(var)</label>
            <committed/>
        </location>
        <location id="id49" x="-11058" y="-11432">
            <label kind="invariant" x="-11118" y="-11483">preSetInit(var, commitment)</label>
            <committed/>
        </location>
        <location id="id50" x="-12425" y="-11296">
            <name x="-12484" y="-11279">loaded</name>
        </location>
        <location id="id51" x="-10293" y="-11101">
            <label kind="invariant" x="-10250" y="-11109">preSaveState()</label>
            <committed/>
        </location>
        <location id="id52" x="-10192" y="-11500">
            <label kind="invariant" x="-10175" y="-11526">preDoStep(stepsize)</label>
            <committed/>
        </location>
        <location id="id53" x="-10345" y="-11543">
            <label kind="invariant" x="-10379" y="-11585">preGet(var)</label>
            <committed/>
        </location>
        <location id="id54" x="-11058" y="-11305">
            <name x="-11143" y="-11296">Initialize</name>
        </location>
        <location id="id55" x="-10549" y="-11492">
            <label kind="invariant" x="-10617" y="-11551">preSet(var, commitment)</label>
            <committed/>
        </location>
        <location id="id56" x="-10072" y="-11305">
        </location>
        <location id="id57" x="-10387" y="-11305">
            <name x="-10498" y="-11330">Simulation</name>
        </location>
        <init ref="id50"/>
        <transition>
            <source ref="id38"/>
            <target ref="id37"/>
            <label kind="guard" x="-9808" y="-11339">action == unload</label>
            <label kind="synchronisation" x="-9808" y="-11322">fmu[id]?</label>
        </transition>
        <transition>
            <source ref="id54"/>
            <target ref="id54"/>
            <label kind="synchronisation" x="-10965" y="-11203">actionPerformed?</label>
            <label kind="assignment" x="-10990" y="-11169">updateEnableActions(true)</label>
            <nail x="-10914" y="-11237"/>
            <nail x="-11016" y="-11177"/>
        </transition>
        <transition>
            <source ref="id56"/>
            <target ref="id38"/>
            <label kind="guard" x="-10030" y="-11339">action == freeInstance</label>
            <label kind="synchronisation" x="-9996" y="-11296">fmu[id]?</label>
        </transition>
        <transition>
            <source ref="id41"/>
            <target ref="id57"/>
            <label kind="synchronisation" x="-10693" y="-11322">actionPerformed!</label>
            <label kind="assignment" x="-10693" y="-11322">updateEnableActions(false)</label>
        </transition>
        <transition>
            <source ref="id54"/>
            <target ref="id41"/>
            <label kind="guard" x="-10965" y="-11348">action == exitInitialization</label>
            <label kind="synchronisation" x="-10939" y="-11331">fmu[id]?</label>
        </transition>
        <transition>
            <source ref="id42"/>
            <target ref="id54"/>
            <label kind="synchronisation" x="-11287" y="-11330">actionPerformed!</label>
            <label kind="assignment" x="-11287" y="-11330">updateEnableActions(true), initialize()</label>
        </transition>
        <transition>
            <source ref="id45"/>
            <target ref="id42"/>
            <label kind="guard" x="-11559" y="-11356">action == enterInitialization</label>
            <label kind="synchronisation" x="-11542" y="-11331">fmu[id]?</label>
        </transition>
        <transition>
            <source ref="id39"/>
            <target ref="id45"/>
            <label kind="synchronisation" x="-11771" y="-11245">actionPerformed!</label>
            <nail x="-11660" y="-11211"/>
        </transition>
        <transition>
            <source ref="id45"/>
            <target ref="id39"/>
            <label kind="guard" x="-11533" y="-11160">action == setParameter</label>
            <label kind="synchronisation" x="-11516" y="-11186">fmu[id]?</label>
            <nail x="-11507" y="-11211"/>
        </transition>
        <transition>
            <source ref="id40"/>
            <target ref="id46"/>
            <label kind="synchronisation" x="-12255" y="-11169">actionPerformed!</label>
            <nail x="-12136" y="-11211"/>
        </transition>
        <transition>
            <source ref="id46"/>
            <target ref="id40"/>
            <label kind="guard" x="-11958" y="-11152">action == setParameter</label>
            <label kind="synchronisation" x="-11924" y="-11211">fmu[id]?</label>
            <nail x="-11932" y="-11203"/>
        </transition>
        <transition>
            <source ref="id43"/>
            <target ref="id45"/>
            <label kind="synchronisation" x="-11779" y="-11330">actionPerformed!</label>
        </transition>
        <transition>
            <source ref="id46"/>
            <target ref="id43"/>
            <label kind="guard" x="-12000" y="-11339">action == setupExperiment</label>
            <label kind="synchronisation" x="-11992" y="-11288">fmu[id]?</label>
        </transition>
        <transition>
            <source ref="id44"/>
            <target ref="id46"/>
            <label kind="synchronisation" x="-12204" y="-11330">actionPerformed!</label>
        </transition>
        <transition>
            <source ref="id50"/>
            <target ref="id44"/>
            <label kind="guard" x="-12400" y="-11339">action == instantiate</label>
            <label kind="synchronisation" x="-12382" y="-11305">fmu[id]?</label>
            <label kind="assignment" x="-12382" y="-11288">
                </label>
        </transition>
        <transition>
            <source ref="id47"/>
            <target ref="id57"/>
            <label kind="synchronisation" x="-10616" y="-11237">actionPerformed!</label>
            <label kind="assignment" x="-10582" y="-11262">restoreState(), updateEnableActions(false)</label>
        </transition>
        <transition>
            <source ref="id57"/>
            <target ref="id47"/>
            <label kind="guard" x="-10472" y="-11058">action == restore</label>
            <label kind="synchronisation" x="-10455" y="-11092">fmu[id]?</label>
            <nail x="-10395" y="-11092"/>
        </transition>
        <transition>
            <source ref="id57"/>
            <target ref="id57"/>
            <label kind="synchronisation" x="-10608" y="-11186">actionPerformed?</label>
            <label kind="assignment" x="-10642" y="-11143">updateEnableActions(false)</label>
            <nail x="-10446" y="-11118"/>
            <nail x="-10540" y="-11211"/>
        </transition>
        <transition>
            <source ref="id48"/>
            <target ref="id54"/>
            <label kind="synchronisation" x="-11228" y="-11237">actionPerformed!</label>
            <label kind="assignment" x="-11245" y="-11211">getValue(var, commitment), updateEnableActions(true)</label>
            <nail x="-11118" y="-11245"/>
        </transition>
        <transition>
            <source ref="id54"/>
            <target ref="id48"/>
            <label kind="guard" x="-10999" y="-11228">action == get</label>
            <label kind="synchronisation" x="-10990" y="-11254">fmu[id]?</label>
            <nail x="-10999" y="-11245"/>
        </transition>
        <transition>
            <source ref="id49"/>
            <target ref="id54"/>
            <label kind="synchronisation" x="-11024" y="-11432">actionPerformed!</label>
            <label kind="assignment" x="-11016" y="-11407">setValue(var, commitment), updateEnableActions(true)</label>
            <nail x="-10999" y="-11373"/>
        </transition>
        <transition>
            <source ref="id54"/>
            <target ref="id49"/>
            <label kind="guard" x="-11186" y="-11449">action == set</label>
            <label kind="synchronisation" x="-11160" y="-11424">fmu[id]?</label>
            <nail x="-11118" y="-11381"/>
        </transition>
        <transition>
            <source ref="id51"/>
            <target ref="id57"/>
            <label kind="synchronisation" x="-10191" y="-11152">actionPerformed!</label>
            <label kind="assignment" x="-10183" y="-11186">saveState(), updateEnableActions(false)</label>
            <nail x="-10191" y="-11160"/>
        </transition>
        <transition>
            <source ref="id52"/>
            <target ref="id57"/>
            <label kind="synchronisation" x="-10158" y="-11466">actionPerformed!</label>
            <label kind="assignment" x="-10149" y="-11415">doStep(stepsize), updateEnableActions(false)</label>
            <nail x="-10132" y="-11373"/>
        </transition>
        <transition>
            <source ref="id53"/>
            <target ref="id57"/>
            <label kind="synchronisation" x="-10294" y="-11551">actionPerformed!</label>
            <label kind="assignment" x="-10362" y="-11483">getValue(var, commitment), updateEnableActions(false)</label>
            <nail x="-10226" y="-11517"/>
        </transition>
        <transition>
            <source ref="id57"/>
            <target ref="id51"/>
            <label kind="guard" x="-10319" y="-11169">action == save</label>
            <label kind="synchronisation" x="-10319" y="-11203">fmu[id]?</label>
        </transition>
        <transition>
            <source ref="id57"/>
            <target ref="id52"/>
            <label kind="guard" x="-10277" y="-11415">action == step</label>
            <label kind="synchronisation" x="-10294" y="-11390">fmu[id]?</label>
        </transition>
        <transition>
            <source ref="id57"/>
            <target ref="id53"/>
            <label kind="guard" x="-10345" y="-11509">action == get</label>
            <label kind="synchronisation" x="-10362" y="-11432">fmu[id]?</label>
        </transition>
        <transition>
            <source ref="id55"/>
            <target ref="id57"/>
            <label kind="synchronisation" x="-10531" y="-11509">actionPerformed!</label>
            <label kind="assignment" x="-10481" y="-11534">setValue(var, commitment), updateEnableActions(false)</label>
            <nail x="-10387" y="-11492"/>
        </transition>
        <transition>
            <source ref="id57"/>
            <target ref="id55"/>
            <label kind="guard" x="-10591" y="-11432">action == set</label>
            <label kind="synchronisation" x="-10540" y="-11407">fmu[id]?</label>
        </transition>
        <transition>
            <source ref="id57"/>
            <target ref="id56"/>
            <label kind="guard" x="-10225" y="-11305">action == terminate</label>
            <label kind="synchronisation" x="-10191" y="-11279">fmu[id]?</label>
        </transition>
    </template>
    <system>
        // Place template instantiations here.
        MasterA = Interpreter();

        //Max number of tries in the loops is upper bounded by the number of FMUs
        loopS = LoopSolver(nFMU + 1);
        finder = StepFinder(H_max + 1);
        loop_solver_init = LoopSolverInit(nFMU + 1);


        //The arguments to FMU is Id, numbers of outputs, number of inputs, definition of inputTypes
        @for(fName<- m.fmuNames) {
        @{fName}_fmu = FMU(@{fName}, @{fName}_output, @{fName}_input, @{fName}_inputTypes) ;
        }

        // List one or more processes to be composed into a system.
        system MasterA,
        @{m.fmuNames.map(fName => s"${fName}_fmu").reduce[String]((a, b) => a + "," + b)},
        loopS, finder, loop_solver_init;
    </system>
    <queries>
        <query>
            <formula>A[] not deadlock
            </formula>
            <comment>
            </comment>
        </query>
        <query>
            <formula>A&lt;&gt; MasterA.Terminated
            </formula>
            <comment>
            </comment>
        </query>
    </queries>
</nta>

