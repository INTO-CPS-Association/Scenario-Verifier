@import core._
        @(m: MaudeModelEncoding)
 
 (omod Ports is 
 protecting QID + NAT .
 sorts PortId Mode PortStatus PortIdSet PStack .
 subsorts Qid < PortId < Oid .
 subsort PortId < PortIdSet .

 sorts Connection SUID EPortId EPortIdSet PScc .
 subsort EPortId < EPortIdSet < PScc .
 subsort EPortId < PStack .
 subsorts Qid < SUID < Oid .
 op _==>_ : EPortId EPortId -> Connection [ctor format(niy! d d d)] .
 subsort Connection < Configuration .
 op _!_ : SUID PortId -> EPortId [ctor] .

 class Port | time : Nat, status : PortStatus . 
 class Input | type : Mode .
 class Output | dependsOn : PortIdSet .
 subclasses Input Output < Port . 
 ops d r : -> Mode [ctor] .   *** d = delayed, r = Reactive.
 ops Def Undef : -> PortStatus [ctor] .


 op emptySet : -> PortIdSet [ctor] .
 op _::_ : PortIdSet PortIdSet -> PortIdSet [ctor assoc comm id: emptySet] .
 
 op emptyLoop : -> EPortIdSet [ctor] .
 op _;;_ : EPortIdSet EPortIdSet -> EPortIdSet [ctor assoc comm id: emptyLoop] .

 op emptyST : -> PStack [ctor] .
 op _##_ : PStack PStack -> PStack [ctor assoc id: emptyST] .

 op sccNoNodes : -> PScc [ctor] .
 op _**_ : PScc PScc -> PScc [ctor assoc comm id: sccNoNodes] .

 op _in_ : EPortId EPortIdSet -> Bool . 
 op _in_ : Connection Configuration -> Bool . 

 op elems : PStack -> EPortIdSet .

 var P : EPortId .
 var PSet : EPortIdSet .
 var Cons : Configuration .
 var C : Connection .
 var STACK : PStack .

 eq elems(emptyST) = emptyLoop .
 eq elems(P ## STACK) = P ;; elems(STACK) .


 eq P in P ;; PSet = true .
 eq P in PSet = false [owise] .

 eq C in C Cons = true .
 eq C in Cons = false [owise] .

 op size : EPortIdSet -> Nat .

 eq size(emptyLoop) = 0 .
 eq size(P ;; PSet) = 1 + size(PSet) .


endom)

(omod Algorithm is 
 protecting Ports .
 sorts ActionType FMIActionType ComplexActionType SUIdSet ActionList Action LoopType Algebraic AlgebraicLoops .
 subsort SUID < SUIdSet .
 subsort Action < ActionList .
 subsort Algebraic < AlgebraicLoops .
    
 *** Types
 ops CreateExp EnterInitialization ExitInitialization Terminate FreeInstance Unload : -> FMIActionType [ctor] . 
 ops Set Get Step Save CreateExp : -> ActionType [ctor] . 
 ops StepNegotiation Loop : -> ComplexActionType [ctor] . 
 ops F R : -> LoopType [ctor] . 
 *** Rename loop type
 op fmiEvent:_SU:_ : FMIActionType PortId -> Action [ctor format(nib! d d d d)] .
 op event:_SU:_PId:_ : ActionType SUID PortIdSet -> Action [ctor format(ni! d d d d d d)] .
 op complexEvent:_SaveSUs:_RestoreSUs:_Actions:_ : ComplexActionType SUIdSet SUIdSet ActionList -> Action [ctor format(niy! d d d d d d d d)] .
 op AlgebraicLoop:_Type:_ : EPortIdSet LoopType -> Algebraic[ctor] . 
 
 *** Configuration fields
 op Algorithm:_ : ActionList -> Configuration [ctor format(nir! d d)] . 
 op SNSet:_ : SUIdSet -> Configuration [ctor format(ni d d)] .
 op stepSize:_ : NzNat -> Configuration [ctor format(nig! d d)] . 
 op endTime:_ : NzNat -> Configuration [ctor format(nim! d d)] . 
 op SCC:_ : AlgebraicLoops -> Configuration [ctor format(nim! d d)] . 
 op guessOn:_ : EPortIdSet -> Configuration [ctor format(nip! d d)] .

 ***Operations
 op emptySUSet : -> SUIdSet [ctor] .
 op _++_ : SUIdSet SUIdSet -> SUIdSet [ctor assoc comm id: emptySUSet] .

 op _in_ : SUID SUIdSet -> Bool . 
 op _memberOf_ : EPortId AlgebraicLoops -> Bool . 

 op emptyList : -> ActionList [ctor] .
 op _;_ : ActionList ActionList -> ActionList [ctor assoc id: emptyList] .

 op noLoops : -> AlgebraicLoops [ctor] .
 op _#_ : AlgebraicLoops AlgebraicLoops -> AlgebraicLoops [ctor assoc id: noLoops] .

 op getSUs : EPortIdSet SUIdSet -> SUIdSet .

 var ID : SUID .
 var SUSet : SUIdSet .
 var L : AlgebraicLoops .
 var P : EPortId .
 var T : LoopType .
 var PSet : EPortIdSet .
 var PID : PortId .

 eq ID in ID ++ SUSet = true .
 eq ID in SUSet = false [owise] .

 eq P memberOf (AlgebraicLoop: (P ;; PSet)  Type: T) # L = true .
 eq P memberOf L = false [owise] .

 eq getSUs(emptyLoop, SUSet) = SUSet .
 ceq getSUs((ID ! PID) ;; PSet, SUSet) = getSUs(PSet, SUSet) if ID in SUSet .
 eq getSUs((ID ! PID) ;; PSet, SUSet) = getSUs(PSet, ID ++ SUSet) [owise] .

endom)

(omod SimulationUnit is
   protecting Ports + Algorithm .
   sort fmiState .

   ops Instantiated ExperimentSetup Initialize Simulation Terminated InstanceFreed Unloaded : -> fmiState [ctor] . *** The different states of the FMI standard

   ***Classes
   class SU | time : Nat, inputs : Configuration, outputs : Configuration, canReject : Bool, state : fmiState .

   op askStepSize : Object NzNat -> NzNat .
   op feedthroughSatisfied : PortIdSet Configuration Nat -> Bool .
   op allDef : Configuration Nat -> Bool .
   op undefPorts : Configuration Nat -> Configuration .
   op undefInputs : Configuration -> Configuration .  
   op allInputsDef : Configuration Nat Nat -> Bool .
   op allInputsSet : Configuration -> Bool .
   op canStep : Nat NzNat Configuration Configuration -> Bool .

   var ID1 : SUID .
   var PId : PortId .
   vars T  SUTime : Nat .
   vars C Inputs Outputs : Configuration .
   var PS : PortStatus .
   var FT : PortIdSet .
   vars FutureTime S : NzNat .

   *** Checks if all feedthrough constraints are satisfied
   eq feedthroughSatisfied(emptySet, C, T) = true .
   eq feedthroughSatisfied(PId :: FT, < PId : Input | status : Undef > C, T) = false .
   eq feedthroughSatisfied(PId :: FT, < PId : Input | time : T, status : Def > C, T) =  feedthroughSatisfied(FT, C, T) .

   eq allDef(none, T) = true .
   eq allDef(< PId : Port | status : PS, time : T > C, T) = PS == Def and allDef(C, T) .

   eq allInputsDef(none, SUTime, FutureTime) = true .
   eq allInputsDef(< PId : Input | time : SUTime, type : d, status : PS > C, SUTime, FutureTime) = PS == Def and allInputsDef(C, SUTime, FutureTime) .
   eq allInputsDef(< PId : Input | time : FutureTime, type : r,  status : PS > C, SUTime, FutureTime ) = PS == Def and allInputsDef(C, SUTime, FutureTime) .

   eq undefPorts(none, T) = none .
   eq undefPorts(< PId : Port | > C, T) =  < PId : Port | status : Undef, time : T > undefPorts(C, T) .

   eq undefInputs(none) = none .
   eq undefInputs(< PId : Port | > C) =  < PId : Port | status : Undef > undefInputs(C) .

   eq allInputsSet(none) = true .
   eq allInputsSet(< ID1 : SU | inputs : Inputs > C) = allDef(Inputs, 0) and allInputsSet(C) .

   eq canStep(SUTime, FutureTime, Inputs, Outputs) =  allInputsDef(Inputs, SUTime, FutureTime) and allDef(Outputs, SUTime) . 

   *** For the moment we allow all steps - should updated to reflect the nondeterminism of the step negotiation!
   eq askStepSize(< ID1 : SU | time : SUTime, inputs : Inputs >, S) = S .

endom)



(omod PerformActions is
  protecting SimulationUnit .
  op getAction : Object PortId -> Object .
  op setAction : Object PortId Nat -> Object .
  op stepAction : Object NzNat -> Object .

  var ID1 : SUID .
  vars I O : PortId .
  var S : NzNat .
  vars INPUTS OUTPUTS : Configuration .
  var ST : Object .
  var T : Nat .

  *** Updates the time and status of the input
  eq getAction(< ID1 : SU | time : T, outputs : (< O : Output | > OUTPUTS) >, O) = < ID1 : SU | outputs : (< O : Output | time : T, status : Def > OUTPUTS) > .

  eq setAction(< ID1 : SU | inputs : (< I : Input | > INPUTS) > , I, T) =  < ID1 : SU | inputs : (< I : Input | time : T, status : Def > INPUTS) > .

  *** Updates the time and the status of the outputs
  eq stepAction(< ID1 : SU | time : T, outputs : OUTPUTS >, S) = < ID1 : SU | time : (T + S), outputs : undefPorts(OUTPUTS, (T + S)) > .

endom)


(omod LOOPSolver is 
  protecting PerformActions .
    sorts Pair .

    op <_;_> : ActionList Configuration -> Pair [ctor] .
    op solveLoop : Configuration Algebraic  -> Configuration . 
    op breakLoop : EPortIdSet Configuration LoopType -> Configuration .
    op containsCycle : AlgebraicLoops -> Bool . 
    op loopStep : EPortIdSet Configuration ActionList -> Pair .
    op solveLoopConf : Configuration Algebraic -> Configuration .
    op solveLoopAlgorithm : Configuration Algebraic -> ActionList .

    op fst : Pair -> ActionList .
    op snd : Pair -> Configuration .

    var L : AlgebraicLoops .  
    var K : LoopType .
    vars C OUTPUTS INPUTS : Configuration .
    vars I O : PortId .
    vars ID1 ID2 : SUID .
    vars PSet GSet : EPortIdSet .
    var AL : ActionList .
    var T T1 : Nat .
    var S : NzNat .
    var FT : PortIdSet .
    var M : Mode .

    eq fst(< AL ; C >) = AL . 
    eq snd(< AL ; C >) = C . 

   *** Does the scenario contain any loop
   eq containsCycle(noLoops) = false .
   eq containsCycle(L) = true [owise] .

   eq solveLoop(C Algorithm: AL, AlgebraicLoop: PSet Type: K) = solveLoopConf(C, AlgebraicLoop: PSet Type: K)
        Algorithm: (AL ; (solveLoopAlgorithm(C, AlgebraicLoop: PSet Type: K))) .

  eq solveLoopConf(C, AlgebraicLoop: PSet Type: K) = snd(loopStep(PSet, breakLoop(PSet, C, K), emptyList)) .

  eq solveLoopAlgorithm(C, AlgebraicLoop: PSet Type: K) = 
    complexEvent: Loop SaveSUs: getSUs(PSet, emptySUSet) RestoreSUs: getSUs(PSet, emptySUSet) 
        Actions: fst(loopStep(PSet, breakLoop(PSet, C, K), emptyList)) .

    *** Forget All Connections depending on type of loop 
    ceq breakLoop((ID1 ! I) ;; PSet,   
                     < ID1 : SU | inputs : (< I : Input | type : M > INPUTS) > 
                     < ID2 : SU | outputs : (< O : Output | > OUTPUTS) > 
                     (ID2 ! O ==> ID1 ! I) guessOn: GSet C, K) = 
                        breakLoop((ID1 ! I) ;; PSet, < ID1 : SU | > < ID2 : SU | > guessOn: ((ID1 ! I) ;; GSet) C , K) 
                        if (K == R and M == r) or (K == F and M == d) .

    eq breakLoop(PSet, C, K) = C [owise] .

    *** Set value using Guess
    ceq loopStep((ID1 ! I) ;; PSet, 
                      < ID1 : SU | time : T, inputs : (< I : Input | time : T1, type : M > INPUTS) > 
                    guessOn: ((ID1 ! I) ;; GSet) stepSize: S C, AL) = 
            loopStep(PSet, 
                    setAction(< ID1 : SU | >, I, T1 + S)
                    guessOn: GSet stepSize: S C, 
                    (AL ; (event: Set SU: ID1 PId: I))) 
                    if (M == r and T1 == T) or (M == d and T == (T1 + S)) .

    *** Set value on input - Fix
    ceq loopStep((ID1 ! I) ;; PSet, 
                      < ID1 : SU | inputs : (< I : Input | time : T, type : M > INPUTS) > 
                      < ID2 : SU | outputs : (< O : Output | time : T1, status : Def > OUTPUTS) > 
                        (ID2 ! O ==> ID1 ! I) C, AL) = 
              loopStep(PSet, 
                      setAction(< ID1 : SU | >, I, T1)
                      < ID2 : SU | > (ID2 ! O ==> ID1 ! I) C, 
                      (AL ; (event: Set SU: ID1 PId: I))) 
                      if T1 > T .

    *** Get output value
    ceq loopStep((ID1 ! O) ;; PSet, 
                    < ID1 : SU | time : T, outputs : (< O : Output | status : Undef, dependsOn : FT > OUTPUTS), inputs : INPUTS > C, AL) = 
                    loopStep(PSet,
                      getAction(< ID1 : SU | >, O) C, 
                      (AL ; (event: Get SU: ID1 PId: O))) 
                      if feedthroughSatisfied(FT, INPUTS, T) .

    *** Step
    ceq loopStep((ID1 ! O) ;; PSet,  
                    < ID1 : SU | time : T, outputs : OUTPUTS, inputs : INPUTS > stepSize: S C, AL) = 
                  loopStep((ID1 ! O) ;; PSet,
                      stepAction(< ID1 : SU | >, S) 
                      stepSize: S C, (AL ; (event: Step SU: ID1 PId: emptySet)))
                    if canStep(T, (T + S), INPUTS, OUTPUTS) .

    eq loopStep(emptyLoop,C, AL) = < AL ; C  > .

endom)


(omod StepFinder is
  protecting LOOPSolver .
  sorts findStepPair .
      
  op <_++_> : NzNat ActionList -> findStepPair [ctor] .
  *** Current State x Initial State -> Nat
  op findStep : SUIdSet Configuration Configuration ActionList -> findStepPair .
  op calculateSNSet : Configuration -> Configuration .
  op needsStepNegotiation : SUIdSet -> Bool .
  op getStep : findStepPair -> NzNat .
  op getAL : findStepPair -> ActionList .
  op stepFindingDone : SUIdSet Configuration NzNat -> Bool .

   vars ID1 ID2 : SUID .
   var SUIDs : SUIdSet .
   vars I O : PortId .
   vars T IT OT : Nat .
   vars S T1 T2 : NzNat .
   vars INPUTS OUTPUTS INPUTS1 : Configuration . 
   vars C C1 : Configuration .
   var AL : ActionList .
   var FT : PortIdSet .
   var L : Algebraic .  
   var LOOPS : AlgebraicLoops .  

   eq stepFindingDone(emptySUSet, C, S) = true .
   eq stepFindingDone(ID1 ++ SUIDs, < ID1 : SU | time : T1 > C, S) = T1 == S and stepFindingDone(SUIDs, C, S) .


   eq getStep( < S ++ AL >) = S .
   eq getAL( < S ++ AL >) = AL .

  *** Step negotiation is needed if at least one SU can reject a Step
  eq needsStepNegotiation(emptySUSet) = false .
  eq needsStepNegotiation(SUIDs) = true [owise] .

   *** Calculation of the members of the set of SUs that should be backtracked in the step negotiation
  ceq calculateSNSet(< ID1 : SU | inputs : (< I : Input | type : r > INPUTS) > 
                      < ID2 : SU | outputs : (< O : Output | > OUTPUTS) > (ID2 ! O ==> ID1 ! I) (SNSet: (ID1 ++ SUIDs))  C) = 
                                         calculateSNSet(< ID1 : SU | > < ID2 : SU | > (ID2 ! O ==> ID1 ! I) 
                                         (SNSet: (ID1 ++ ID2 ++ SUIDs)) C) 
                                         if not ID2 in SUIDs .
  
  ceq calculateSNSet(< ID1 : SU | canReject : true > (SNSet: SUIDs) C ) = calculateSNSet(< ID1 : SU | > (SNSet: (ID1 ++ SUIDs)) C )
                                         if not ID1 in SUIDs .                                    
  eq calculateSNSet(C) = C [owise] .

  *** Get case (only on reactive outputs)
  ceq findStep(ID1 ++ ID2 ++ SUIDs, 
                    < ID2 : SU | time : T, outputs : (< O : Output | status : Undef, dependsOn : FT > OUTPUTS), inputs : INPUTS1 >
                    < ID1 : SU | inputs : (< I : Input | type : r > INPUTS) > (ID2 ! O ==> ID1 ! I) C, C1, AL) = 
                    findStep(ID1 ++ ID2 ++ SUIDs, getAction(< ID2 : SU | >, O) < ID1 : SU | >  (ID2 ! O ==> ID1 ! I) C, C1, AL ; (event: Get SU: ID2 PId: O)) 
                    if feedthroughSatisfied(FT, INPUTS1, T) .

  *** Set case (only on reactive Inputs)
  ceq findStep(ID1 ++ ID2 ++ SUIDs, 
                      < ID1 : SU | inputs : (< I : Input | time : IT, type : r > INPUTS) > 
                      < ID2 : SU | outputs : (< O : Output | time : OT, status : Def > OUTPUTS) > 
                        (ID2 ! O ==> ID1 ! I) C, C1, AL) = 
              findStep(ID1 ++ ID2 ++ SUIDs, setAction(< ID1 : SU | >, I, OT) < ID2 : SU | > (ID2 ! O ==> ID1 ! I) C, C1, AL ; (event: Set SU: ID1 PId: I)) 
              if IT < OT .

  ***Stepping case
  ceq findStep(ID1 ++ SUIDs,  
                    < ID1 : SU | time : T, outputs : OUTPUTS, inputs : INPUTS > stepSize: S C, C1, AL) = 
                  findStep(ID1 ++ SUIDs,
                  stepAction(< ID1 : SU | >, (askStepSize(< ID1 : SU | >, S))) stepSize: (askStepSize(< ID1 : SU | >, S)) C, C1, AL ; (event: Step SU: ID1 PId: emptySet))
                    if canStep(T, (T + S), INPUTS, OUTPUTS) .

  *** Restart search and and update step size for next iteration of search
  ceq findStep(ID1 ++ ID2 ++ SUIDs, 
                        < ID1 : SU | time : T1 > 
                        < ID2 : SU | time : T2 > C, C1 stepSize: S, AL) = 
              findStep(ID1 ++ ID2 ++ SUIDs, C1 stepSize: min(T1, T2), C1 stepSize: min(T1, T2), AL)   
                    if T1 =/= T2 . *** The simulations should both have stepped, but not to the same time

  *** Solve Algebraic Loops
  eq findStep(SUIDs, C SCC: (L # LOOPS), C1 SCC: (L # LOOPS), AL) = findStep(SUIDs, solveLoopConf(C SCC: LOOPS, L), C1 SCC: LOOPS, AL ; solveLoopAlgorithm(C SCC: LOOPS, L)) [owise] . 

  ceq findStep(SUIDs, C stepSize: S, C1, AL) = < S ++ AL > if stepFindingDone(SUIDs, C, S) . 

endom)



(omod COSIMULATION is 
   protecting StepFinder .
   sort GlobalState .

   op performStepNegotiation : Configuration -> Configuration .
   op performGlobalStep : Configuration -> Configuration .
   op allSUinSimulation : Configuration -> Bool .
   op `{_`} : Configuration -> GlobalState .
   op getPorts : Configuration EPortIdSet -> EPortIdSet .
   op simulationStepDone : Configuration -> Bool .

   vars ID1 ID2 : SUID .
   var SUIDs : SUIdSet .
   vars I O : PortId .
   vars T T1 T2 : Nat .
   vars INPUTS OUTPUTS C : Configuration . 
   var ST : fmiState .
   var AL : ActionList .
   var FT : PortIdSet .
   var P : EPortIdSet .
   var S : NzNat .
   var L : Algebraic .  
   var LOOPS : AlgebraicLoops .  
   var M : Mode .

  eq simulationStepDone(< ID1 : SU | time : T, inputs : INPUTS, outputs : OUTPUTS > C) = T > 0 and allDef(INPUTS, T) and allDef(OUTPUTS, T) and simulationStepDone(C) .
  eq simulationStepDone(C) = true [owise] .

  *** Step Negotiation
  ceq performStepNegotiation(C SNSet: SUIDs stepSize: S Algorithm: AL) = 
                              C SNSet: emptySUSet 
                                Algorithm: (AL ; (complexEvent: StepNegotiation SaveSUs: SUIDs RestoreSUs: SUIDs 
                                Actions: getAL(findStep(SUIDs, C stepSize: S, C stepSize: S, emptyList))))
                              (stepSize: getStep(findStep(SUIDs, C stepSize: S, C stepSize: S, emptyList)))
                              if needsStepNegotiation(SUIDs) .

  ceq performStepNegotiation(C SNSet: SUIDs) = C if not needsStepNegotiation(SUIDs) .  

  *** Get All ports in the scenario:
  ceq getPorts(< ID1 : SU | inputs : (< I : Input | > INPUTS) > C, P) = getPorts(< ID1 : SU | > C,  (ID1 ! I) ;; P )
            if not (ID1 ! I) in P .

  ceq getPorts(< ID1 : SU | outputs : (< O : Output | > OUTPUTS) > C, P) = getPorts(< ID1 : SU | > C,  (ID1 ! O) ;; P )
            if not (ID1 ! O) in P .

  eq getPorts(C, P) = P [owise] . 

  *** All SUs are in the simulation state
  eq allSUinSimulation(< ID1 : SU | state : ST > C) = ST == Simulation and allSUinSimulation(C) . 
  eq allSUinSimulation(C) = true [owise] .

  *** Perform the global simulation step
  *** Set input
  ceq performGlobalStep(C < ID1 : SU | time : T, inputs : (< I : Input | time : T1, type : M > INPUTS) > 
                          < ID2 : SU | outputs : (< O : Output | time : T2, status : Def > OUTPUTS) > 
                         (ID2 ! O ==> ID1 ! I) Algorithm: AL) = 
            performGlobalStep(C setAction( < ID1 : SU | >, I, T2) < ID2 : SU | > 
                         (ID2 ! O ==> ID1 ! I) 
                         Algorithm: (AL ; (event: Set SU: ID1 PId: I)))
                         if T1 < T2 and ((M == d and T1 < T) or (M == r and T == T1)) .

  *** Step
  ceq performGlobalStep(C < ID1 : SU | time : T, inputs : INPUTS, outputs : OUTPUTS > stepSize: S endTime: T2 Algorithm: AL)  = 
      performGlobalStep(C 
                        stepAction(< ID1 : SU | >, S)
                        stepSize: S endTime: T2 Algorithm: (AL ; (event: Step SU: ID1 PId: emptySet)))
                        if canStep(T, (T + S), INPUTS, OUTPUTS) and (T + S) <= T2 . 

  *** Get
  ceq performGlobalStep(C < ID1 : SU | time : T, inputs : INPUTS, outputs : (< O : Output | status : Undef, dependsOn : FT > OUTPUTS) >       Algorithm: AL) =
                    performGlobalStep(C getAction(< ID1 : SU | >, O) Algorithm: (AL ; (event: Get SU: ID1 PId: O)))  
                    if feedthroughSatisfied(FT, INPUTS, T) .

  *** Algebraic Loop - solve and remove loop
  eq performGlobalStep(C SCC: (L # LOOPS)) = solveLoop(C SCC: LOOPS, L) [owise] .

  *** 
  ceq performGlobalStep(C) = C if simulationStepDone(C) .

  *** FMI-standard state transition:
  rl [setExp] : < ID1 : SU | state : Instantiated > Algorithm: AL 
                 => < ID1 : SU | state : ExperimentSetup > Algorithm: (AL ; (fmiEvent: CreateExp SU: ID1)) .

  rl [init] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, state : ExperimentSetup >  Algorithm: AL 
           => < ID1 : SU | inputs : undefPorts(INPUTS, 0), outputs : undefPorts(OUTPUTS, 0), state : Initialize > 
              Algorithm: (AL ; (fmiEvent: EnterInitialization SU: ID1)).

  crl [simulate] : < ID1 : SU | inputs : INPUTS , outputs : OUTPUTS, state : Initialize > C Algorithm: AL 
                => < ID1 : SU | state : Simulation > C Algorithm: (AL ; (fmiEvent: ExitInitialization SU: ID1))
                if allDef(INPUTS, 0) and allDef(OUTPUTS, 0) and allInputsSet(C) .

  crl [terminate] : < ID1 : SU | time : T, inputs : INPUTS , outputs : OUTPUTS , state : Simulation > endTime: T Algorithm: AL 
                 => < ID1 : SU | state : Terminated > endTime: T Algorithm: (AL ; (fmiEvent: Terminate SU: ID1))
                 if allDef(OUTPUTS, T) and allDef(INPUTS, T) .

  rl [free] : < ID1 : SU | state : Terminated > Algorithm: AL 
           => < ID1 : SU | state : InstanceFreed > Algorithm: (AL ; (fmiEvent: FreeInstance SU: ID1)) .

  rl [unload] : < ID1 : SU | state : InstanceFreed > Algorithm: AL
              => < ID1 : SU | state : Unloaded > Algorithm: (AL ; (fmiEvent: Unload SU: ID1)) .


   *** Initalization Procedure 
   crl [get-init] :  < ID1 : SU | outputs : ((< O : Output | status : Undef , dependsOn : FT >) OUTPUTS) , inputs : INPUTS, state : Initialize > Algorithm: AL 
                  => 
                  getAction(< ID1 : SU | >, O)                  
                  Algorithm: (AL ; (event: Get SU: ID1 PId: O)) if feedthroughSatisfied(FT, INPUTS, 0) .

   *** Inputs can only rely on one connection 
   rl [set-init] :  < ID1 : SU | inputs : (< I : Input | status : Undef > INPUTS), state : Initialize > Algorithm: AL 
                    < ID2 : SU | outputs : (< O : Output | status : Def > OUTPUTS) > (ID2 ! O ==> ID1 ! I)
                        => 
                           setAction(< ID1 : SU | >, I, 0)
                           < ID2 : SU | > (ID2 ! O ==> ID1 ! I) Algorithm: (AL ; (event: Set SU: ID1 PId: I)) .


  ***rl [init-loop] : C SCC: (L # LOOPS) => solveLoop(C SCC: LOOPS, L) .                 

 ***Complex scenarios with save and restore - this should 

  ***If the scenario contains SUs that require step negotiation
  ***The step negotiation
  crl [stepNego] : { C SNSet: SUIDs} => 
          { performStepNegotiation(C SNSet: SUIDs)}
          if needsStepNegotiation(SUIDs) and allSUinSimulation(C) .


  crl [simulationStep]: { C SNSet: SUIDs} => 
          { performGlobalStep(C SNSet: SUIDs) }
        if (not needsStepNegotiation(SUIDs)) and allSUinSimulation(C) .

   *** Definition of system
  op externalConnection : ->  Configuration .    *** External Connections - all ports have unique name
  op simulationUnits : -> Configuration .      *** SUs - ID * input ports * and outputs

  op setup : -> GlobalState .

***Encoding of the Scenario
@m.scenario


endom)


(omod ScenarioEnvironment is
    protecting COSIMULATION .
    sorts Environment IndexMap IndexMapEntry DFSR PStackTuple .
    subsort IndexMapEntry < IndexMap .

    op findSuccesors : EPortId Configuration -> EPortIdSet .
    op succesors : EPortId Configuration EPortIdSet -> EPortIdSet .
    op split : EPortId PStack -> PStackTuple .
    op addStackIncr : EPortId Environment -> Environment .

    op createIndexMap : EPortIdSet IndexMap -> IndexMap .

    op emptyMap : -> IndexMap [ctor] .
    op _^^_ : IndexMap IndexMap -> IndexMap [ctor assoc comm id: emptyMap] .

    *** Data constructors - can potentially be better (we have a lot of pairs)!
    op env : PStack PScc Nat IndexMap -> Environment [ctor] .
    op map : EPortId Nat -> IndexMapEntry [ctor] .
    op natEnv : Nat Environment -> DFSR [ctor] .
    op pTuple : PStack PStack -> PStackTuple [ctor] .

    *** Projection functions
    op num : DFSR -> Nat .
    op dfsrEnv : DFSR -> Environment .
    op fstStack : PStackTuple -> PStack .
    op sndStack : PStackTuple -> PStack .
    op getLoops : Environment Configuration -> AlgebraicLoops .
    op isReactiveLoop : EPortIdSet Configuration -> Bool .

    *** Get fields in Environment
    op getSN : Environment -> Nat .
    op getStack : DFSR -> PStack .
    op getSCC : DFSR -> PScc .
    op getIM : DFSR -> IndexMap .

    op nodeHasBeenVisited : EPortId Environment -> Bool .
    op createAlgebraic : PScc Configuration AlgebraicLoops -> AlgebraicLoops .
    op setInfty : EPortIdSet IndexMap -> IndexMap .

    vars ID1 ID2 : SUID .
    vars I O : PortId .
    var P : EPortId .
    var PSet : EPortIdSet .
    var FT : PortIdSet .
    var IM : IndexMap .
    vars C INPUTS OUTPUTS : Configuration .
    vars STACK STACK1 STACK2 : PStack .
    vars SCCs L : PScc .
    var LOOPS : AlgebraicLoops .
    var N : NzNat .
    vars M M1 : Nat .
    var E : Environment .

    *** Projection function
    eq getStack(natEnv(M, env(STACK, SCCs, M1, IM))) = STACK .
    eq getSN(env(STACK, SCCs, M, IM)) = M .
    eq getSCC(natEnv(M, env(STACK, SCCs, M1, IM))) = SCCs .
    eq getIM(natEnv(M, env(STACK, SCCs, M1, IM))) = IM .

    eq addStackIncr(P, env(STACK, SCCs, M1, map(P, M) ^^ IM)) = env(P ## STACK, SCCs, (M1 + 1), map(P, M1) ^^ IM) .


    *** The node has been visited if its index is non-zero
    eq nodeHasBeenVisited(P, env(STACK, SCCs, M, map(P, N) ^^ IM)) = true .
    eq nodeHasBeenVisited(P, E) = false [owise] .

    
    *** Transform environment to Algebraic Loops
    eq getLoops(env(STACK, SCCs , M, IM), C) = createAlgebraic(SCCs, C, noLoops) .

    ***Encode everything as algebraic loops:
    *** No more SCC to look at
    eq createAlgebraic(sccNoNodes, C, LOOPS) = LOOPS .

    ceq createAlgebraic(PSet ** SCCs, C, LOOPS) = createAlgebraic(SCCs, C, (AlgebraicLoop: PSet Type: R) # LOOPS)  
        if size(PSet) > 1 and isReactiveLoop(PSet, C) .

    ceq createAlgebraic(PSet ** SCCs, C, LOOPS) = createAlgebraic(SCCs, C, (AlgebraicLoop: PSet Type: F) # LOOPS)  
        if size(PSet) > 1 and not(isReactiveLoop(PSet, C)) .
    
    *** Trivial SCC should be forgotten
    eq createAlgebraic(PSet ** SCCs, C, LOOPS) = createAlgebraic(SCCs, C, LOOPS) [owise] .

    *** Check type of SCC
    eq isReactiveLoop((ID1 ! I) ;; PSet, < ID1 : SU | inputs : (< I : Input | type : r > INPUTS) > C) = true .
    eq isReactiveLoop(PSet, C) = false [owise] .

    *** Split the DFS-result to its components 
    eq num(natEnv(M, E)) = M .
    eq dfsrEnv(natEnv(M, E)) = E .

    *** Sets all nodes in the stack to infinity - to ensure they do not interfere with the future calculations
    eq setInfty(emptyST, IM) = IM .
    eq setInfty(P ## STACK, map(P, N) ^^ IM) = setInfty(STACK, map(P, 100000) ^^ IM) .

    *** Create the initial INDEX map - all index are 0
    eq createIndexMap(emptyLoop, IM) = IM .
    eq createIndexMap(P ;; PSet, map(P, N) ^^ IM) = createIndexMap(PSet, map(P, N) ^^ IM) .
    eq createIndexMap(P ;; PSet, IM) = createIndexMap(PSet, map(P, 0) ^^ IM) [owise] .

    *** Split the PStackTuple
    eq fstStack(pTuple(STACK1, STACK2)) = STACK1 .
    eq sndStack(pTuple(STACK1, STACK2)) = STACK2 .

    *** Splits the stack at P
    eq split(P, emptyST) = pTuple(emptyST, emptyST) . *** Nothing is on the stack
    eq split(P, STACK1 ## P ## STACK2 ) = pTuple(STACK1 ## P, STACK2) . *** P is on the stack
    eq split(P, STACK1) = pTuple(STACK1, emptyST) [owise] . *** P is not on the stack

    *** Wrapper method
    eq findSuccesors(P, C) = succesors(P, C, emptyLoop) .

    *** Output
    ceq succesors((ID2 ! O), 
                < ID1 : SU | inputs : (< I : Input | > INPUTS) > 
                < ID2 : SU | outputs : (< O : Output | > OUTPUTS) > 
                         (ID2 ! O ==> ID1 ! I) C, PSet) = 
                    succesors((ID1 ! O), < ID1 : SU | inputs : (< I : Input | > INPUTS) > 
                                         < ID2 : SU | outputs : (< O : Output | > OUTPUTS) > 
                                            (ID2 ! O ==> ID1 ! I) C, 
                                         (ID1 ! I) ;; PSet) 
                    if not (ID1 ! I) in PSet .

    *** Input - feed through
    ceq succesors((ID1 ! I),
                    < ID1 : SU | inputs : (< I : Input | > INPUTS), outputs : (< O : Output | dependsOn : I :: FT > OUTPUTS) > C, PSet) 
                    = 
                    succesors((ID1 ! I), 
                    < ID1 : SU | inputs : (< I : Input | > INPUTS), outputs : (< O : Output | > OUTPUTS) > C,
                    (ID1 ! O) ;; PSet) 
                    if not (ID1 ! O) in PSet .

    *** Input - reactive
    ceq succesors((ID1 ! I),
                < ID1 : SU | inputs : (< I : Input | type : r > INPUTS), outputs : (< O : Output | > OUTPUTS) > C, PSet) 
                = 
                succesors((ID1 ! I), 
                < ID1 : SU | inputs : (< I : Input | > INPUTS), outputs : (< O : Output | > OUTPUTS) > C,
                (ID1 ! O) ;; PSet) 
                if not (ID1 ! O) in PSet .


    eq succesors(P, C, PSet) = PSet [owise] .




endom)

(omod ScenarioAnalyser is
    protecting ScenarioEnvironment .

    op tarjan : Configuration -> AlgebraicLoops .
    op dfs : EPortIdSet Environment Configuration -> DFSR .
    op dfs1 : EPortId Environment Configuration -> DFSR .

    var P : EPortId .
    var PSet : EPortIdSet .
    var IM : IndexMap .
    var C : Configuration .
    var STACK  : PStack .
    var SCCs : PScc .
    var N : NzNat .
    var M : Nat .
    var E : Environment .

    eq tarjan(C) = getLoops(dfsrEnv(dfs(getPorts(C, emptyLoop), env(emptyST, sccNoNodes, 1, createIndexMap(getPorts(C, emptyLoop), emptyMap)), C)), C) .

    *** P has been visisted before - N is non-zero!
    eq dfs(P ;; PSet, env(STACK, SCCs, M, map(P, N) ^^ IM), C) = 
        natEnv(
            min(N, num(dfs(PSet, env(STACK, SCCs, M, map(P, N) ^^ IM), C))),
            dfsrEnv(dfs(PSet, env(STACK, SCCs, M, map(P, N) ^^ IM), C))
        ) .

    *** Dead end - no successor!
    eq dfs(emptyLoop, E, C) = natEnv(100000, E) .

    *** P has not been visited before
    eq dfs(P ;; PSet, E, C) = 
        natEnv(
            min(num(dfs1(P, E, C)), num(dfs(PSet, dfsrEnv(dfs1(P, E, C)), C))),
            dfsrEnv(dfs(PSet, dfsrEnv(dfs1(P, E, C)), C))
        ) [owise] .
    
    *** If we can find a Node with a lower index we use the lower index
    ceq dfs1(P, E, C) = dfs(findSuccesors(P, C), addStackIncr(P, E), C)
        if(num (dfs(findSuccesors(P, C), addStackIncr(P, E), C)) < getSN(E)) .
            
    *** If we cannot find a Node with a lower index
    eq dfs1(P, E, C) =                 
                natEnv(100000, 
                    env(
                        sndStack(split(P, getStack(dfs(findSuccesors(P, C), addStackIncr(P, E), C)))),
                        getSCC(dfs(findSuccesors(P, C), addStackIncr(P, E), C)) 
                            ** elems(fstStack(split(P, getStack(dfs(findSuccesors(P, C), addStackIncr(P, E), C))))),
                        getSN(dfsrEnv(dfs(findSuccesors(P, C), addStackIncr(P, E), C))),
                        setInfty(
                            fstStack(split(P, getStack(dfs(findSuccesors(P, C), addStackIncr(P, E), C)))), 
                            getIM(dfs(findSuccesors(P, C), addStackIncr(P, E), C))
                        )
                    )
                )
                [owise] .

    eq setup = { calculateSNSet(simulationUnits externalConnection stepSize: 1 endTime: 1 Algorithm: emptyList SNSet: emptySUSet guessOn: emptyLoop SCC: tarjan(simulationUnits externalConnection)) } .

    
endom)