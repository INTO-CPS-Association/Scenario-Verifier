@import core._
        @(m: ModelEncoding)
        <?xml version="1.0" encoding="utf-8"?>
        <!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
    <declaration>
        //***********************************************************************************************************
        //Do not change
        const int END_TIME = 1;
        const int START_TIME = 0;
        int currentConfig := 0;

        //Is the stepFinder active
        bool stepFinderActive := false;

        //We need to run an extra iteration of the stepFinder and loopSolver with all checks activated
        // once the loop has converged
        bool isLoopExtraIteration := false;
        bool isStepExtraIteration := false;

        //These is simply to keep track of which loop is the inner one - in case of nested loops
        bool isLoopNested := false;
        bool isStepNested := false;

        //Active loop - if it is different form -1, we are in the middle of solving an algebraic loop
        int loopActive := -1;

        //Used in Trace Visualization
        int isInit := 0;
        int isSimulation := 0;

        bool checksDisabled = false;

        //In case of a scenario with algebraic loops and step rejection,
        // we need to be able to turn off the precondition checks
        bool shouldChecksBeDisabled(){
            //In case a loop is not activated all checks should be
            if(loopActive == -1 &amp;&amp; !stepFinderActive){
                return false;
            }

            //We are inside a loop is it nested
            if(isLoopNested || isStepNested){
                //Both loops should be on the extraIteration
                return !(isStepExtraIteration &amp;&amp; isLoopExtraIteration);
            }

            //Not nested - if none of the loops is in the extra iteration we should disable the checks
            if(!isLoopExtraIteration &amp;&amp; !isStepExtraIteration){
                return true;
            }

            return false;
        }

        //FMU of a variable
        const int undefined := 0;
        const int defined := 1;
        const int notStable :=-1;

        //FMU of the variable
        typedef struct {
            int[-1,1] status;
            int time;
        } variable;


        //Const assignment types - to future variables or current:
        const int final := 0;
        const int tentative := 1;
        const int noCommitment := -1;

        //***********************************************************************************************************

        //Max number of inputs/outputs any FMU can have - Should be changed
        const int MaxNInputs = @m.maxNInputs;
        const int MaxNOutputs = @m.maxNOutputs;

        //Numbers of FMUs in scenario - Should be changed
        const int nFMU = @m.nFMUs;

        //number of algebraic loops in scenario - Should be changed
        const int nAlgebraicLoopsInStep := @m.nAlgebraicLoopsInStep;

        //Adaptive co-simulation - numbers of different configurations
        const int nConfig := @m.nConfigs;
        //***********************************************************************************************************
        //Do not change

        const int NActions := 14;

        //The number of actions in our system
        const int N := MaxNInputs &gt; MaxNOutputs? MaxNInputs : MaxNOutputs;

        //The maximum step allowed in system - shouldn't be changed
        const int H_max := @m.Hmax;
        const int H := H_max;

        const int noStep := -1;
        const int noFMU := -1;
        const int noLoop := -1;

        typedef struct {
            int[-1, nFMU] FMU;
            int[-1,NActions] act;
            int[-1,N] portVariable;
            int[-1,H] step_size;
            int[-1,nFMU] relative_step_size;
            int[-1,1] commitment;
            int[-1, nAlgebraicLoopsInStep] loop;
        } Operation;

        typedef struct {
            int[-1,nFMU] FMU;
            int[-1, MaxNInputs] input;
            int[-1, MaxNOutputs] output;
        } InternalConnection;

        //Types of input ports
        const int delayed := 0;
        const int reactive := 1;
        const int noPort := -1;

        typedef struct {
            int[0, nFMU] SrcFMU;
            int[0,MaxNOutputs] output;
            int[0,nFMU] TrgFMU;
            int[0,MaxNInputs] input;
        } ExternalConnection;

        typedef struct {
            int[-1,nFMU] FMU;
            int[-1, MaxNOutputs] port;
        } FmuOutputPort;


        //The action dictates which action will be executed
        const int noOp := -1;
        const int get := 0;
        const int set := 1;
        const int step := 2;
        const int save := 3;
        const int restore := 4;
        const int setParameter := 5;
        const int instantiate := 6;
        const int enterInitialization := 7;
        const int exitInitialization := 8;
        const int loop := 9;
        const int findStep := 10;
        const int setupExperiment := 11;
        const int unload := 12;
        const int terminate := 13;
        const int freeInstance := 14;

        int[-1,NActions] action;

        //The activeFMU variable dictates which FMU is enabled - which FMU should take an action
        int[-1, nFMU] activeFMU = 0;

        //Channels
        //A channel to invoke an FMU-action from the Interpreter, StepFinder, LoopSolver
        chan fmu[nFMU];

        //A channel for all actions - I can use fewer channels and use the actions to distinguish
        broadcast chan actionPerformed;

        //A channel to start the stepFinder
        chan findStepChan;

        //Channel to start and finish LoopSolver
        chan solveLoop;

        //Channel to start and finish LoopSolver for Init
        chan solveLoopInit;

        //A broadcase channel for an FMU to signal an error
        chan ErrorChan;

        //The fmu-variable that is updated by the action
        int [-1,N] var = 0;
        //The variable that is being get or set (either the current or future time) by the action
        int [-1,1] commitment = 0;
        //The stepsize of the step action
        int [-1, H_max] stepsize = 0;
        int [-1, nFMU] relative_step_size = 0;

        const int end = END_TIME;
        int time = START_TIME;

        //***********************************************************************************************************
        //Scenario Dependent - Should be changed!

        //Number of internal connections - both init and normal
        const int nInternal := @m.nInternal;

        //Number of external connections in scenario
        const int nExternal := @m.nExternal;

        //The initial of value of h
        int h := H_max;

        //This array is representing the variables of the stepSize that each FMU can take - H_max is the default value
        int stepVariables[nFMU] = {@m.stepVariables};

        //A generic action to pick the next action
        void unpackOperation(Operation operation){
            //action to be performed
            action := operation.act;
            //fmu to perform the action
            activeFMU := operation.FMU;
            //The variable involved
            var := operation.portVariable;
            //The Stepsize
            stepsize := operation.step_size;
            //The Stepsize
            relative_step_size := operation.relative_step_size;
            //The commitment
            commitment := operation.commitment;
            if(loopActive == noLoop){
                loopActive := operation.loop;
            }
            if(action == step){
                if (stepsize == noStep) {
                    // Step is relative to the fmu referred to by relative_step_size
                    stepsize := stepVariables[relative_step_size];
                } else if (stepsize == H) {
                    // Default step
                    stepsize := h;
                } else {
                    // Absolute step size
                    // Nothing to do.
                }
            }
            //Update checkStatus
            checksDisabled = shouldChecksBeDisabled();
        }


        //Encoding of the scenario
        //Each FMU should have a different ID \in [0, nFMU-1]
        @for(fName<- m.fmuNames) {
        const int @fName := @m.fmuId(fName);
        }

        //Number of inputs and outputs of each FMU
        @for(fName<- m.fmuNames) {
        const int @{fName}_input := @m.nInputs(fName);
        const int @{fName}_output := @m.nOutputs(fName);
        }

        //Definition of inputs and outputs of each FMU
        @for(fName<- m.fmuNames) {
        // @fName inputs - @m.nInputs(fName)
        @for(inName<- m.fmuInNames(fName)) {
        const int @{m.fmuPortName(fName, inName)} := @m.fmuInputEncoding(fName)(inName);
        }
        // @fName outputs - @m.nOutputs(fName)
        @for(outName<- m.fmuOutNames(fName)) {
        const int @{m.fmuPortName(fName, outName)} := @m.fmuOutputEncoding(fName)(outName);
        }
        const int @{fName}_inputTypes[nConfig][MaxNInputs] := { @m.fmuInputTypes(fName) };
        }

        //This array is to keep track of the value of each output port - each output port needs two variables (current and future)
        // and each variable is having two values (defined and time)
        variable connectionVariable[nFMU][MaxNOutputs][2] = { @m.connectionVariable };

        //Connections - do not longer contain the type of the input - but it is still a 1:1 mapping
        const ExternalConnection external[nConfig][nExternal] = { @m.external };

        const InternalConnection feedthroughInStep[nConfig][nInternal] = { @m.feedthroughInStep };

        //The array show if an FMU can reject a step or not - if the FMU can reject a step the value is 1 on the index defined by the fmus
        const bool mayRejectStep[nFMU] = { @m.mayRejectStep };


        const int maxStepOperations := @m.maxStepOperations;

        //Numbers of operations in each step
        const int[0,maxStepOperations] nStepOperations[nConfig] := {@m.nStepOperations};

        // Number of operations in the step finding loop
        const int maxFindStepOperations := @m.maxFindStepOperations;
        const int maxFindStepRestoreOperations := @m.maxFindStepRestoreOperations;

        const int[0,maxFindStepOperations] nFindStepOperations[nConfig] := {@m.nFindStepOperations};
        const int[0,maxFindStepRestoreOperations] nRestore[nConfig] := {@m.nRestore};

        // Numbers for algebraic loop operations in step
        const int maxNAlgebraicLoopOperationsInStep := @m.maxNAlgebraicLoopOperationsInStep;
        const int maxNRetryOperationsForAlgebraicLoopsInStep := @m.maxNRetryOperationsForAlgebraicLoopsInStep;
        const int maxNConvergeOperationsForAlgebraicLoopsInStep := @m.maxNConvergeOperationsForAlgebraicLoopsInStep;

        //Numbers of operations to be performed per algebraic loop in step
        const int[0,maxNConvergeOperationsForAlgebraicLoopsInStep] nConvergencePortsPerAlgebraicLoopInStep[nConfig][nAlgebraicLoopsInStep] = {@m.nConvergencePortsPerAlgebraicLoopInStep};
        const int[0,maxNAlgebraicLoopOperationsInStep] nOperationsPerAlgebraicLoopInStep[nConfig][nAlgebraicLoopsInStep] = {@m.nOperationsPerAlgebraicLoopInStep};
        const int[0,maxNRetryOperationsForAlgebraicLoopsInStep] nRetryOperationsPerAlgebraicLoopInStep[nConfig][nAlgebraicLoopsInStep] = {@m.nRetryOperationsPerAlgebraicLoopInStep};

        //These operations define what should be performed in the simulation - it is assumed that the operation first loads the fmus
        const Operation stepOperations[nConfig][maxStepOperations] = { @m.stepOperations };

        //These are the operations to be performed in order to find the correct step
        //In these operation there is a difference on the third parameter to doStep:
        // H (A step-value greater than the allowed step (Greater than the number of FMUS)) means that we should look at the variable h
        // A stepSize (0:(nFMU-1)) means that the should look at that index in stepVariables use that as the step
        //This is being done inside - findStepAction

        const Operation findStepIteration[nConfig][maxFindStepOperations] = { @m.findStepLoopOperations };
        const Operation StepFix[nConfig][maxFindStepRestoreOperations] = { @m.findStepLoopRestoreOperations };

        //Possible multiple loops
        //Loop operations are to solve algebraic loops in the co-simulation scenario
        const Operation operationsPerAlgebraicLoopInStep[nConfig][nAlgebraicLoopsInStep][maxNAlgebraicLoopOperationsInStep] = {@m.operationsPerAlgebraicLoopInStep };

        //The converge ports is to mark which variables that needs to be checked in the convergence loop
        //The convention is now to specify the FMU first and the port to denote the variables that should be checked
        const FmuOutputPort convergencePortsPerAlgebraicLoopInStep[nConfig][nAlgebraicLoopsInStep][maxNConvergeOperationsForAlgebraicLoopsInStep] = {@m.convergencePortsPerAlgebraicLoopInStep };

        const Operation retryOperationsPerAlgebraicLoopInStep[nConfig][nAlgebraicLoopsInStep][maxNRetryOperationsForAlgebraicLoopsInStep] = {@m.retryOperationsPerAlgebraicLoopInStep };

    </declaration>
<template>
<name>Interpreter</name>
<declaration>
    int inst_pc := 0;
    int cosimstep_pc := 0;
    int n := 0;

    void selectNextCosimStepAction(){
        if(cosimstep_pc &lt; nStepOperations[currentConfig]){
            unpackOperation(stepOperations[currentConfig][cosimstep_pc]);
        }
        //Proceed to next action
        cosimstep_pc++;
    }

    void takeStep(int global_h, int newConfig){
        //h is progression of time
        time := time + h;
        //Reset the loop actions
        cosimstep_pc := 0;
        //reset the global stepsize
        h := global_h;
        //reset n
        n := 0;
        currentConfig := newConfig;
    }

    void setStepsizeFMU(int fmu, int fmu_step_size){
        if(mayRejectStep[fmu]){
            //If an FMU can reject a Step it is maximum step should be updated in each iteration
            stepVariables[fmu] = fmu_step_size;
        }else{
            //If not just set its maximum step to the global step
            stepVariables[fmu] = h;
        }
        n++;
    }
</declaration>
    <location id="id0" x="1674" y="187">
        <name x="1700" y="178">Terminated</name>
    </location>
    <location id="id1" x="1113" y="-102">
        <committed/>
    </location>
    <location id="id2" x="841" y="-102">
        <committed/>
    </location>
    <location id="id3" x="2176" y="-127">
        <name x="2227" y="-152">Error</name>
    </location>
    <location id="id4" x="2048" y="25">
        <name x="1988" y="68">SolveAlgebraicLoop</name>
    </location>
    <location id="id5" x="2065" y="-221">
        <name x="2055" y="-255">FindStep</name>
    </location>
    <location id="id6" x="1351" y="-102">
        <name x="1325" y="-144">CosimStep</name>
        <committed/>
    </location>
    <location id="id7" x="1521" y="-425">
        <name x="1427" y="-484">NormalFMUAction</name>
    </location>
    <location id="id8" x="1674" y="-102">
        <name x="1691" y="-68">Simulate</name>
        <committed/>
    </location>
    <init ref="id2"/>
    <transition>
        <source ref="id8"/>
        <target ref="id0"/>
        <label kind="guard" x="1691" y="102">cosimstep_pc == nStepOperations[currentConfig] + 1 </label>
    </transition>
    <transition>
        <source ref="id1"/>
        <target ref="id1"/>
        <label kind="select" x="1020" y="-306">step_fmu:int[1,H_max]</label>
        <label kind="guard" x="1037" y="-289">n &lt; nFMU</label>
        <label kind="assignment" x="1011" y="-272">setStepsizeFMU(n, step_fmu)</label>
        <nail x="1003" y="-246"/>
        <nail x="1198" y="-246"/>
    </transition>
    <transition>
        <source ref="id1"/>
        <target ref="id6"/>
        <label kind="guard" x="1181" y="-136">n == nFMU</label>
    </transition>
    <transition>
        <source ref="id8"/>
        <target ref="id1"/>
        <label kind="select" x="1232" y="76">global_h:int[1,H_max], config:int[0,nConfig-1]</label>
        <label kind="guard" x="1079" y="34">cosimstep_pc == nStepOperations[currentConfig] + 1
            &amp;&amp; time &lt; end</label>
        <label kind="assignment" x="1190" y="136">takeStep(global_h,config), isSimulation= 0</label>
        <nail x="1351" y="34"/>
    </transition>
    <transition>
        <source ref="id2"/>
        <target ref="id1"/>
    </transition>
    <transition>
        <source ref="id4"/>
        <target ref="id3"/>
        <label kind="synchronisation" x="1980" y="-17">ErrorChan?</label>
        <nail x="2176" y="25"/>
    </transition>
    <transition>
        <source ref="id5"/>
        <target ref="id3"/>
        <label kind="synchronisation" x="2065" y="-255">ErrorChan?</label>
        <nail x="2176" y="-221"/>
    </transition>
    <transition>
        <source ref="id4"/>
        <target ref="id8"/>
        <label kind="synchronisation" x="1784" y="-26">solveLoop?</label>
        <label kind="assignment" x="1801" y="8">selectNextCosimStepAction()</label>
    </transition>
    <transition>
        <source ref="id8"/>
        <target ref="id4"/>
        <label kind="guard" x="1903" y="-93">loopActive != -1
            &amp;&amp; action == loop</label>
        <label kind="synchronisation" x="1818" y="-127">solveLoop!</label>
        <nail x="2065" y="-110"/>
    </transition>
    <transition>
        <source ref="id5"/>
        <target ref="id8"/>
        <label kind="synchronisation" x="1861" y="-416">findStepChan?</label>
        <label kind="assignment" x="1861" y="-391">selectNextCosimStepAction(),
            stepFinderActive := false</label>
        <nail x="1946" y="-365"/>
    </transition>
    <transition>
        <source ref="id8"/>
        <target ref="id5"/>
        <label kind="guard" x="1844" y="-221">action == findStep</label>
        <label kind="synchronisation" x="2005" y="-170">findStepChan!</label>
        <label kind="assignment" x="1997" y="-195">stepFinderActive := true</label>
    </transition>
    <transition>
        <source ref="id6"/>
        <target ref="id8"/>
        <label kind="assignment" x="1326" y="-161">selectNextCosimStepAction(), isSimulation = 1</label>
        <nail x="1521" y="-102"/>
    </transition>
    <transition>
        <source ref="id7"/>
        <target ref="id8"/>
        <label kind="synchronisation" x="1631" y="-493">actionPerformed?</label>
        <label kind="assignment" x="1631" y="-467">selectNextCosimStepAction()</label>
        <nail x="1716" y="-442"/>
    </transition>
    <transition>
        <source ref="id8"/>
        <target ref="id7"/>
        <label kind="guard" x="1334" y="-382">(action == get ||
            action == set ||
            action == step ||
            action == save ||
            action == restore)
            &amp;&amp; cosimstep_pc &lt; (nStepOperations[currentConfig] +1)</label>
        <label kind="synchronisation" x="1470" y="-255">fmu[activeFMU]!</label>
    </transition>
</template>
<template>
<name>LoopSolver</name>
<parameter>int maxIteration</parameter>
<declaration>
    int convergence_pc := 0;
    int restore_pc := 0;
    bool isFeedthrough = false;

    //Number of iteration run in the loop Solver
    int currentConvergeLoopIteration := 0;



    void selectNextLoopAction(int l){
        unpackOperation(operationsPerAlgebraicLoopInStep[currentConfig][l][convergence_pc]);
        //Proceed to next action
        convergence_pc ++;
    }

    void selectNextRestoreAction(int l){
        unpackOperation(retryOperationsPerAlgebraicLoopInStep[currentConfig][l][restore_pc]);
        restore_pc++;
    }


    void updateConvergenceVariables(int l){
        int fmu;
        int v;
        int i = 0;
        for(i = 0; i &lt; nConvergencePortsPerAlgebraicLoopInStep[currentConfig][l]; i++){
            fmu = convergencePortsPerAlgebraicLoopInStep[currentConfig][l][i].FMU;
            v = convergencePortsPerAlgebraicLoopInStep[currentConfig][l][i].port;
            if(isFeedthrough){
                connectionVariable[fmu][v][tentative].status := connectionVariable[fmu][v][final].status;
                connectionVariable[fmu][v][tentative].time := connectionVariable[fmu][v][final].time;
            }else{
                connectionVariable[fmu][v][final].status := connectionVariable[fmu][v][tentative].status;
                connectionVariable[fmu][v][final].time := connectionVariable[fmu][v][tentative].time;
            }
        }
    }

    void loopConverge(){
        //Loop not longer active
        loopActive := -1;
        //Loop action counter reset
        convergence_pc := 0;
        //Reset convergence counter
        currentConvergeLoopIteration := 0;
        isLoopExtraIteration:= false;
        isFeedthrough := false;
    }


    void resetConvergenceloop(){
        convergence_pc := 0;
        restore_pc := 0;
        selectNextLoopAction(loopActive);
    }

    //Convergence will happen when all convergenceVariables have a similar future and current value
    bool convergenceCriteria(int l){
        return forall(x:int[0,maxNConvergeOperationsForAlgebraicLoopsInStep-1])
            convergencePortsPerAlgebraicLoopInStep[currentConfig][l][x].FMU != noFMU imply
            connectionVariable[convergencePortsPerAlgebraicLoopInStep[currentConfig][l][x].FMU][convergencePortsPerAlgebraicLoopInStep[currentConfig][l][x].port][final].status
            ==
            connectionVariable[convergencePortsPerAlgebraicLoopInStep[currentConfig][l][x].FMU][convergencePortsPerAlgebraicLoopInStep[currentConfig][l][x].port][tentative].status
            &amp;&amp;
            connectionVariable[convergencePortsPerAlgebraicLoopInStep[currentConfig][l][x].FMU][convergencePortsPerAlgebraicLoopInStep[currentConfig][l][x].port][final].time
            ==
            connectionVariable[convergencePortsPerAlgebraicLoopInStep[currentConfig][l][x].FMU][convergencePortsPerAlgebraicLoopInStep[currentConfig][l][x].port][tentative].time;
    }

    bool convergence(int l){
        return (convergenceCriteria(l) &amp;&amp; isLoopExtraIteration);
    }


    void updateIsExtra(int l){
        if(convergenceCriteria(l)){
            isLoopExtraIteration := true;
        }
    }
</declaration>
<location id="id24" x="-1011" y="-518">
    <committed/>
</location>
<location id="id25" x="-1079" y="-663">
</location>
<location id="id26" x="-442" y="-824">
    <name x="-494" y="-858">NotConverging</name>
</location>
<location id="id27" x="-340" y="-255">
    <name x="-297" y="-229">UpdateVariables</name>
    <committed/>
</location>
<location id="id28" x="-17" y="-518">
</location>
<location id="id29" x="-340" y="-518">
    <name x="-332" y="-509">RestoreState</name>
    <committed/>
</location>
<location id="id30" x="-739" y="-518">
    <name x="-714" y="-543">CheckConvergence</name>
    <committed/>
</location>
<location id="id31" x="-1088" y="-357">
</location>
<location id="id32" x="-1343" y="-518">
    <committed/>
</location>
<location id="id33" x="-1708" y="-518">
</location>
<init ref="id33"/>
<transition>
    <source ref="id29"/>
    <target ref="id27"/>
    <label kind="guard" x="-476" y="-382">action == noOp</label>
    <label kind="assignment" x="-493" y="-357">isFeedthrough = true</label>
</transition>
<transition>
    <source ref="id24"/>
    <target ref="id32"/>
    <label kind="guard" x="-1283" y="-748">convergence_pc &lt; nOperationsPerAlgebraicLoopInStep[currentConfig][loopActive]</label>
    <label kind="assignment" x="-1283" y="-510">selectNextLoopAction(loopActive)</label>
</transition>
<transition>
    <source ref="id32"/>
    <target ref="id25"/>
    <label kind="guard" x="-1292" y="-646">action == findStep</label>
    <label kind="synchronisation" x="-1317" y="-612">findStepChan!</label>
    <label kind="assignment" x="-1334" y="-680">isStepNested := true</label>
</transition>
<transition>
    <source ref="id24"/>
    <target ref="id30"/>
    <label kind="guard" x="-1003" y="-467">convergence_pc == nOperationsPerAlgebraicLoopInStep[currentConfig][loopActive]</label>
    <label kind="assignment" x="-993" y="-518">currentConvergeLoopIteration++</label>
</transition>
<transition>
    <source ref="id25"/>
    <target ref="id24"/>
    <label kind="synchronisation" x="-1011" y="-612">findStepChan?</label>
    <label kind="assignment" x="-1020" y="-586">isStepNested = false</label>
</transition>
<transition>
    <source ref="id31"/>
    <target ref="id24"/>
    <label kind="synchronisation" x="-1020" y="-433">actionPerformed?</label>
</transition>
<transition>
    <source ref="id32"/>
    <target ref="id31"/>
    <label kind="guard" x="-1309" y="-374">action == get ||
        action == set ||
        action == step</label>
    <label kind="synchronisation" x="-1282" y="-403">fmu[activeFMU]!</label>
</transition>
<transition>
    <source ref="id27"/>
    <target ref="id32"/>
    <label kind="assignment" x="-1402" y="-212">updateConvergenceVariables(loopActive),
        resetConvergenceloop()</label>
    <nail x="-1309" y="-246"/>
    <nail x="-1343" y="-246"/>
</transition>
<transition>
    <source ref="id30"/>
    <target ref="id26"/>
    <label kind="guard" x="-816" y="-867">!convergence(loopActive) &amp;&amp;
        currentConvergeLoopIteration == maxIteration</label>
    <label kind="synchronisation" x="-646" y="-892">ErrorChan!</label>
    <nail x="-671" y="-628"/>
    <nail x="-671" y="-824"/>
</transition>
<transition>
    <source ref="id28"/>
    <target ref="id27"/>
    <label kind="guard" x="-195" y="-416">restore_pc == nRetryOperationsPerAlgebraicLoopInStep[currentConfig][loopActive]</label>
    <label kind="synchronisation" x="-221" y="-280">actionPerformed?</label>
    <nail x="-17" y="-255"/>
</transition>
<transition>
    <source ref="id28"/>
    <target ref="id29"/>
    <label kind="guard" x="-272" y="-731">restore_pc &lt; nRetryOperationsPerAlgebraicLoopInStep[currentConfig][loopActive]</label>
    <label kind="synchronisation" x="-272" y="-705">actionPerformed?</label>
    <label kind="assignment" x="-297" y="-663">selectNextRestoreAction(loopActive)</label>
    <nail x="-17" y="-680"/>
    <nail x="-340" y="-680"/>
</transition>
<transition>
    <source ref="id29"/>
    <target ref="id28"/>
    <label kind="guard" x="-255" y="-586">action == restore</label>
    <label kind="synchronisation" x="-247" y="-552">fmu[activeFMU]!</label>
    <nail x="-213" y="-518"/>
</transition>
<transition>
    <source ref="id30"/>
    <target ref="id33"/>
    <label kind="guard" x="-1249" y="-816">convergence(loopActive)</label>
    <label kind="synchronisation" x="-1071" y="-816">solveLoop!</label>
    <label kind="assignment" x="-1385" y="-859">loopConverge()</label>
    <nail x="-739" y="-790"/>
    <nail x="-1105" y="-790"/>
    <nail x="-1708" y="-790"/>
</transition>
<transition>
    <source ref="id30"/>
    <target ref="id29"/>
    <label kind="guard" x="-671" y="-586">!convergence(loopActive) &amp;&amp;
        currentConvergeLoopIteration &lt; maxIteration</label>
    <label kind="assignment" x="-663" y="-510">selectNextRestoreAction(loopActive),
        updateIsExtra(loopActive)</label>
</transition>
<transition>
    <source ref="id33"/>
    <target ref="id32"/>
    <label kind="guard" x="-1581" y="-569">loopActive != -1
        &amp;&amp; action == loop</label>
    <label kind="synchronisation" x="-1505" y="-536">solveLoop?</label>
    <label kind="assignment" x="-1632" y="-493">selectNextLoopAction(loopActive),
        currentConvergeLoopIteration := 0</label>
    <nail x="-1377" y="-518"/>
</transition>
</template>
<template>
<name>StepFinder</name>
<parameter>const int maxTries</parameter>
<declaration>
    int step_pc := 0;
    int restore_pc := 0;
    int numbersOfTries := 0;

    void selectNextStepFinderAction(){
        unpackOperation(findStepIteration[currentConfig][step_pc]);
        step_pc++;
    }

    void selectNextStepRestoreAction(){
        unpackOperation(StepFix[currentConfig][restore_pc]);
        restore_pc++;
    }

    void findMinStep(){
        //Maximum step size allowed
        int min = nFMU;
        int j := 0;
        for(j = 0; j &lt; nFMU; j++){
            if(stepVariables[j] &lt; min){
                min := stepVariables[j];
            }
        }
        h := min;
    }


    bool stepFound(){
        //All FMU that may reject a step should be able to take the same step - h
        return forall(x:int[0, nFMU-1]) mayRejectStep[x] imply stepVariables[x] == h;
    }

    bool loopConverged(){
        return (stepFound() &amp;&amp; isStepExtraIteration);
    }


    void updateIsExtra(){
        if(stepFound()){
            isStepExtraIteration := true;
            //Reset numbers of tries to 0 - This is to avoid problems with the maximum number of tries and not to active the nested checks
            numbersOfTries := 0;
        }
    }
</declaration>
<location id="id34" x="1122" y="-178">
    <committed/>
</location>
<location id="id35" x="-34" y="-178">
    <committed/>
</location>
<location id="id36" x="-144" y="17">
</location>
<location id="id37" x="817" y="144">
    <committed/>
</location>
<location id="id38" x="654" y="-578">
    <name x="644" y="-612">NoCommonStep</name>
</location>
<location id="id39" x="-1427" y="-178">
    <name x="-1478" y="-187">Start</name>
</location>
<location id="id40" x="1011" y="-331">
</location>
<location id="id41" x="732" y="-178">
    <name x="681" y="-237">Reset</name>
    <committed/>
</location>
<location id="id42" x="348" y="-178">
    <committed/>
</location>
<location id="id43" x="-144" y="-382">
</location>
<location id="id44" x="-510" y="-178">
    <committed/>
</location>
<init ref="id39"/>
<transition>
    <source ref="id39"/>
    <target ref="id44"/>
    <label kind="synchronisation" x="-1105" y="-212">findStepChan?</label>
    <label kind="assignment" x="-1156" y="-161">selectNextStepFinderAction()</label>
</transition>
<transition>
    <source ref="id34"/>
    <target ref="id37"/>
    <label kind="guard" x="884" y="110">nRestore[currentConfig] == restore_pc</label>
    <nail x="1147" y="-178"/>
    <nail x="1147" y="144"/>
</transition>
<transition>
    <source ref="id34"/>
    <target ref="id41"/>
    <label kind="guard" x="892" y="-212">restore_pc &lt; nRestore[currentConfig]</label>
    <label kind="assignment" x="901" y="-170">selectNextStepRestoreAction()</label>
</transition>
<transition>
    <source ref="id40"/>
    <target ref="id34"/>
    <label kind="synchronisation" x="1062" y="-289">actionPerformed?</label>
</transition>
<transition>
    <source ref="id35"/>
    <target ref="id44"/>
    <label kind="guard" x="-365" y="-212">step_pc &lt; nFindStepOperations[currentConfig]</label>
    <label kind="assignment" x="-416" y="-178">selectNextStepFinderAction()</label>
</transition>
<transition>
    <source ref="id36"/>
    <target ref="id35"/>
    <label kind="synchronisation" x="-51" y="-85">solveLoop?</label>
    <label kind="assignment" x="-102" y="-51">isLoopNested := false</label>
</transition>
<transition>
    <source ref="id35"/>
    <target ref="id42"/>
    <label kind="guard" x="-16" y="-212">nFindStepOperations[currentConfig] == step_pc</label>
    <label kind="assignment" x="110" y="-161">findMinStep(),
        numbersOfTries++</label>
</transition>
<transition>
    <source ref="id43"/>
    <target ref="id35"/>
    <label kind="synchronisation" x="-85" y="-323">actionPerformed?</label>
</transition>
<transition>
    <source ref="id44"/>
    <target ref="id36"/>
    <label kind="guard" x="-459" y="-51">action == loop</label>
    <label kind="synchronisation" x="-459" y="-76">solveLoop!</label>
    <label kind="assignment" x="-442" y="8">isLoopNested := true</label>
</transition>
<transition>
    <source ref="id37"/>
    <target ref="id44"/>
    <label kind="assignment" x="-459" y="170">step_pc := 0, restore_pc := 0, selectNextStepFinderAction()</label>
    <nail x="-510" y="153"/>
</transition>
<transition>
    <source ref="id42"/>
    <target ref="id38"/>
    <label kind="guard" x="407" y="-561">!stepFound() &amp;&amp;
        numbersOfTries == maxTries</label>
    <label kind="synchronisation" x="484" y="-510">ErrorChan!</label>
</transition>
<transition>
    <source ref="id42"/>
    <target ref="id39"/>
    <label kind="guard" x="-1258" y="-748">loopConverged()</label>
    <label kind="synchronisation" x="-1258" y="-722">findStepChan!</label>
    <label kind="assignment" x="-1258" y="-688">step_pc := 0, isStepExtraIteration := false, restore_pc:=0,
        numbersOfTries := 0</label>
    <nail x="76" y="-612"/>
    <nail x="-1428" y="-612"/>
</transition>
<transition>
    <source ref="id41"/>
    <target ref="id40"/>
    <label kind="synchronisation" x="782" y="-348">fmu[activeFMU]!</label>
</transition>
<transition>
    <source ref="id42"/>
    <target ref="id41"/>
    <label kind="guard" x="416" y="-221">!loopConverged() &amp;&amp;
        numbersOfTries &lt; maxTries</label>
    <label kind="assignment" x="433" y="-161">selectNextStepRestoreAction(),
        updateIsExtra()</label>
</transition>
<transition>
    <source ref="id44"/>
    <target ref="id43"/>
    <label kind="guard" x="-467" y="-382">action == get ||
        action == set ||
        action == step</label>
    <label kind="synchronisation" x="-484" y="-289">fmu[activeFMU]!</label>
</transition>
</template>
<template>
<name>FMU</name>
<parameter>const int id, const int nOutput, const int nInput, const int inputType[nConfig][MaxNInputs]</parameter>
<declaration>
    int cTime := START_TIME;
    variable inputVariables[MaxNInputs] = { @{m.variableArray(m.maxNInputs)} };
    variable outputVariables[MaxNOutputs] = { @{m.variableArray(m.maxNOutputs)} };
    //Index for the for-loop
    int i := 0;

    //Backup FMU
    variable savedOutputVariables[MaxNOutputs];
    variable savedInputVariables[MaxNInputs];
    int savedTime;
    bool isSaved := false;
    bool isConsistent := true;
    bool isInitialized := false;

    int stepEnabled := false;
    bool getEnabled[MaxNOutputs] := { @m.getEnabled };
    bool setEnabled[MaxNInputs] := { @m.setEnabled };

    void initialize(){
        isInitialized := true;
        //Set all variables to undefined
        for(i = 0; i &lt; nInput; i++){
            inputVariables[i].status := undefined;
            inputVariables[i].time := 0;
        }
        for(i := 0; i &lt; nOutput; i++){
            outputVariables[i].status := undefined;
            outputVariables[i].time := 0;
        }
    }

    void getValue(int v, int a){
        outputVariables[v].status := defined;
        outputVariables[v].time := cTime;

        connectionVariable[id][v][a].status := defined;
        connectionVariable[id][v][a].time := cTime;
    }

    void setValue(int v, int a){
        inputVariables[v].status := defined;
        for(i = 0; i &lt; nExternal; i++){
            if(external[currentConfig][i].TrgFMU == id &amp;&amp; external[currentConfig][i].input == v){
                inputVariables[v].time := connectionVariable[external[currentConfig][i].SrcFMU][external[currentConfig][i].output][a].time;
            }
        }
    }

    //Proceed in time - we will start by assuming an FMU can't reject a stepsize
    void doStep(int t){
        //Checking of step is valid
        if(t &gt; stepVariables[id]){
        //Step is too big and will not be allowed - t is reset too the biggest allowed step
            t := stepVariables[id];
        }

        //Take step
        cTime := cTime + t;

        isConsistent := true;

        for(i = 0; i &lt; nInput; i++){
            if(inputVariables[i].time != cTime){
                isConsistent := false;
            }
        }

        //Reset outputs accesssed and advance their timestamp
        for(i = 0; i &lt; nOutput; i++){
            //The inputs of the FMUs are inconsistent (not all are at time cTime) - so the FMUs output valid should be set to NaN
            if(isConsistent){
                outputVariables[i].status := undefined;
                outputVariables[i].time := cTime;
            }else{
                outputVariables[i].status := notStable;
                outputVariables[i].time := cTime;
            }
        }

        isConsistent := true;

        //Update or return the taken step size
        stepVariables[id] := t;
    }

    void restoreFMU(){
        outputVariables := savedOutputVariables;
        inputVariables := savedInputVariables;
        cTime := savedTime;
    }

    void saveFMU(){
        savedOutputVariables := outputVariables;
        savedInputVariables := inputVariables;
        savedTime := cTime;
        isSaved := true;
    }

    bool preSet(int v, int a){
        if(checksDisabled){
        return true;
    }

    //If the connection is reactive the connected variable needs to have a greater than the time of the FMU and be defined
    return (forall(x:int[0, nExternal-1]) external[currentConfig][x].TrgFMU == id &amp;&amp; external[currentConfig][x].input == v &amp;&amp;
    inputType[currentConfig][v] == reactive imply connectionVariable[external[currentConfig][x].SrcFMU][external[currentConfig][x].output][a].status == defined &amp;&amp;
    connectionVariable[external[currentConfig][x].SrcFMU][external[currentConfig][x].output][a].time &gt; cTime) &amp;&amp;
    (forall(x:int[0, nExternal-1]) external[currentConfig][x].TrgFMU == id &amp;&amp; external[currentConfig][x].input == v &amp;&amp; inputType[currentConfig][v] == delayed
    imply connectionVariable[external[currentConfig][x].SrcFMU][external[currentConfig][x].output][a].status == defined &amp;&amp;
    connectionVariable[external[currentConfig][x].SrcFMU][external[currentConfig][x].output][a].time == cTime);
    }


    bool preGet(int v){
        if(checksDisabled){
            return true;
        }

        //All internal connections should be defined at time cTime
        return forall(x:int[0, nInternal-1]) feedthroughInStep[currentConfig][x].FMU == id &amp;&amp; feedthroughInStep[currentConfig][x].output == v
            imply inputVariables[feedthroughInStep[currentConfig][x].input].status == defined &amp;&amp; inputVariables[feedthroughInStep[currentConfig][x].input].time == cTime;
    }

    bool preDoStep(int t){
        if(checksDisabled){
            return true;
        }

        //All delayed input ports should be defined at the current time
        //And all reactive inputs ports should be defined at the next time step
        return (forall(x:int[0, MaxNInputs-1]) inputType[currentConfig][x] == reactive imply inputVariables[x].status == defined &amp;&amp; inputVariables[x].time == cTime + t) &amp;&amp;
            (forall(x:int[0, MaxNInputs-1]) inputType[currentConfig][x] == delayed imply inputVariables[x].status == defined &amp;&amp; inputVariables[x].time == cTime);
    }

        //An FMU can only enter the Simulation mode when all connected FMU variables are defined at time 0
    bool preSimulation(){
        return ((forall(x:int[0, MaxNOutputs-1]) outputVariables[x].status == defined &amp;&amp; outputVariables[x].time == 0)
        &amp;&amp; (forall(x:int[0, MaxNInputs-1]) inputVariables[x].status == defined &amp;&amp;
        inputVariables[x].time == 0));
    }

    bool preSaveFMU(){
        //Always possible
        return true;
    }

    bool preRestoreFMU(){
        //Should a requirement be a saved previous FMU?
        return isSaved;
    }

    void updateEnableActions(){
        for(i = 0; i &lt; nInput; i++){
            setEnabled[i] := preSet(i, final);
        }
        for(i := 0; i &lt; nOutput; i++){
            getEnabled[i] := preGet(i);
        }
        stepEnabled := preDoStep(h);
    }

</declaration>
    <location id="id37" x="-10285" y="-11662">
        <committed/>
    </location>
    <location id="id38" x="-10752" y="-11305">
        <label kind="invariant" x="-10795" y="-11279">preSimulation()</label>
        <committed/>
    </location>
    <location id="id39" x="-10183" y="-11475">
        <label kind="invariant" x="-10174" y="-11458">preRestoreFMU()</label>
        <committed/>
    </location>
    <location id="id40" x="-10030" y="-11373">
        <label kind="invariant" x="-10047" y="-11407">preSaveFMU()</label>
        <committed/>
    </location>
    <location id="id41" x="-10336" y="-11492">
        <label kind="invariant" x="-10370" y="-11466">preDoStep(stepsize)</label>
        <committed/>
    </location>
    <location id="id42" x="-10523" y="-11500">
        <label kind="invariant" x="-10599" y="-11492">preGet(var)</label>
        <committed/>
    </location>
    <location id="id43" x="-10642" y="-11441">
        <label kind="invariant" x="-10812" y="-11492">preSet(var, commitment)</label>
        <committed/>
    </location>
    <location id="id44" x="-10387" y="-11305">
        <name x="-10498" y="-11330">Simulation</name>
    </location>
    <init ref="id38"/>
    <transition>
        <source ref="id37"/>
        <target ref="id44"/>
        <label kind="synchronisation" x="-10183" y="-11679">actionPerformed!</label>
        <label kind="assignment" x="-9928" y="-11560">updateEnableActions()</label>
        <nail x="-9936" y="-11653"/>
        <nail x="-9936" y="-11313"/>
    </transition>
    <transition>
        <source ref="id40"/>
        <target ref="id37"/>
        <label kind="assignment" x="-10149" y="-11602">saveFMU()</label>
        <nail x="-10038" y="-11526"/>
    </transition>
    <transition>
        <source ref="id39"/>
        <target ref="id37"/>
        <label kind="assignment" x="-10259" y="-11526">restoreFMU()</label>
    </transition>
    <transition>
        <source ref="id41"/>
        <target ref="id37"/>
        <label kind="assignment" x="-10361" y="-11560">doStep(stepsize)</label>
    </transition>
    <transition>
        <source ref="id42"/>
        <target ref="id37"/>
        <label kind="assignment" x="-10557" y="-11577">getValue(var, commitment)</label>
    </transition>
    <transition>
        <source ref="id43"/>
        <target ref="id37"/>
        <label kind="assignment" x="-10565" y="-11679">setValue(var, commitment)</label>
        <nail x="-10582" y="-11645"/>
    </transition>
    <transition>
        <source ref="id38"/>
        <target ref="id44"/>
    </transition>
    <transition>
        <source ref="id44"/>
        <target ref="id39"/>
        <label kind="guard" x="-10259" y="-11390">action == restore</label>
        <label kind="synchronisation" x="-10302" y="-11373">fmu[id]?</label>
        <nail x="-10200" y="-11390"/>
    </transition>
    <transition>
        <source ref="id44"/>
        <target ref="id44"/>
        <label kind="synchronisation" x="-10633" y="-11203">actionPerformed?</label>
        <label kind="assignment" x="-10659" y="-11177">updateEnableActions()</label>
        <nail x="-10438" y="-11143"/>
        <nail x="-10557" y="-11237"/>
    </transition>
    <transition>
        <source ref="id44"/>
        <target ref="id40"/>
        <label kind="guard" x="-10234" y="-11339">action == save</label>
        <label kind="synchronisation" x="-10140" y="-11356">fmu[id]?</label>
    </transition>
    <transition>
        <source ref="id44"/>
        <target ref="id41"/>
        <label kind="guard" x="-10369" y="-11415">action == step</label>
        <label kind="synchronisation" x="-10361" y="-11398">fmu[id]?</label>
    </transition>
    <transition>
        <source ref="id44"/>
        <target ref="id42"/>
        <label kind="guard" x="-10489" y="-11475">action == get</label>
        <label kind="synchronisation" x="-10463" y="-11449">fmu[id]?</label>
    </transition>
    <transition>
        <source ref="id44"/>
        <target ref="id43"/>
        <label kind="guard" x="-10608" y="-11441">action == set</label>
        <label kind="synchronisation" x="-10633" y="-11415">fmu[id]?</label>
    </transition>
</template>
    <system>
        // Place template instantiations here.
        MasterA = Interpreter();

        //Max number of tries in the loops is upper bounded by the number of FMUs
        loopS = LoopSolver(nFMU + 1);
        finder = StepFinder(H_max + 1);

        //The arguments to FMU is Id, numbers of outputs, number of inputs, definition of inputTypes
        @for(fName<- m.fmuNames) {
        @{fName}_fmu = FMU(@{fName}, @{fName}_output, @{fName}_input, @{fName}_inputTypes) ;
        }

        // List one or more processes to be composed into a system.
        system MasterA,
        @{m.fmuNames.map(fName => s"${fName}_fmu").reduce[String]((a, b) => a + "," + b)},
        loopS, finder;
    </system>
    <queries>
        <query>
            <formula>A&lt;&gt; MasterA.Terminated
            </formula>
            <comment>
            </comment>
        </query>
    </queries>
</nta>

