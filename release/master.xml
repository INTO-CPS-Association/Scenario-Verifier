<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>
		//***********************************************************************************************************
		//Do not change
		const int END_TIME = 1;
		const int START_TIME = 0;

		//Is the stepFinder active
		bool stepFinderActive := false;

		//We need to run an extra iteration of the stepFinder and loopSolver with all checks activated
		//  once the loop has converged
		bool isLoopExtraIteration := false;
		bool isStepExtraIteration := false;

		//These is simply to keep track of which loop is the inner one - in case of nested loops
		bool isLoopNested := false;
		bool isStepNested := false;

		//Active loop - if it is different form -1, we are in the middle of solving an algebraic loop
		int loopActive := -1;

		//In case of a scenario with algebraic loops and step rejection,
		//  we need to be able to turn off the precondition checks
		bool shouldChecksBeDisabled(){

			//In case a loop is not activated all checks should be
			if(loopActive == -1 &amp;&amp; !stepFinderActive){
				return false;
			}

			//We are inside a loop is it nested
			if(isLoopNested || isStepNested){
				//Both loops should be on the extraIteration
				return !(isStepExtraIteration &amp;&amp; isLoopExtraIteration);
			}

			//Not nested - if none of the loops is in the extra iteration we should disable the checks
			if(!isLoopExtraIteration &amp;&amp; !isStepExtraIteration){
				return true;
			}

			return false;
		}

		//State of a variable
		const int undefined := 0;
		const int defined := 1;
		const int notStable :=-1;

		//State of the variable
		typedef struct {
			int[-1,1] status;
			int time;
		} variable;


		//Const assignment types - to future variables or current:
		const int final := 0;
		const int tentative := 1;
		const int noCommitment := -1;

		//***********************************************************************************************************

		//Max number of inputs/outputs any FMU can have - Should be changed
		const int MaxNInputs = 4;
		const int MaxNOutputs = 3;

		//Numbers of FMUs in scenario - Should be changed
		const int nFMU = 4;

		//number of algebraic loops in scenario  - Should be changed
		const int nLoops := 1;

		//***********************************************************************************************************
		//Do not change

		const int NActions := 14;

		//The number of actions in our system
		const int N := MaxNInputs &gt; MaxNOutputs? MaxNInputs : MaxNOutputs;

		//The maximum step allowed in system - shouldn't be changed
		const int H_max := nFMU;
		const int H := 2 * H_max;

		const int noStep := -1;
		const int noFMU := -1;
		const int noLoop := -1;

		typedef struct {
			int[-1, nFMU] FMU;
			int[-1,NActions] act;
			int[-1,N] portVariable;
			int[-1,H] step_size;
			int[-1,1] commitment;
			int[-1, nLoops] loop;
		} Operation;

		typedef struct {
			int[0,nFMU] FMU;
			int[0, MaxNInputs] input;
			int[0, MaxNOutputs] output;
		} InternalConnection;

		//Types of input ports
		const int delayed := 0;
		const int reactive := 1;
		const int noPort := -1;

		typedef struct {
			int[0, nFMU] SrcFMU;
			int[0,MaxNOutputs] output;
			int[0,nFMU] TrgFMU;
			int[0,MaxNInputs] input;
		} ExternalConnection;

		typedef struct {
    		int[-1,nFMU] FMU;
    		int[-1, MaxNOutputs] port;
		} FmuOutputPort;


		//The action dictates which action will be executed
		const int noOp := -1;
		const int get := 0;
		const int set := 1;
		const int step := 2;
		const int save := 3;
		const int restore := 4;
		const int setParameter := 5;
		const int instantiate := 6;
		const int enterInitialization := 7;
		const int exitInitialization := 8;
		const int loop := 9;
		const int findStep := 10;
		const int setupExperiment := 11;
		const int unload := 12;
		const int terminate := 13;
		const int freeInstance := 14;

		int[-1,NActions] action;

		//Channels
		//A channel to invoke an FMU-action from the Interpreter, StepFinder, LoopSolver
		chan fmu[nFMU];

		//A channel for all actions - I can use fewer channels and use the actions to distinguish
		chan actionPerformed;

		//A channel to start the stepFinder
		chan findStepChan;

		//Channel to start and finish LoopSolver
		chan solveLoop;

		//A broadcase channel for an FMU to signal an error
		chan ErrorChan;

		//The fmu-variable that is updated by the action
		int [-1,N] var = 0;
		//The variable that is being get or set (either the current or future time) by the action
		int [-1,1] commitment = 0;
		//The stepsize of the step action
		int [-1,H_max] stepsize = 0;

		int end = END_TIME;
		int time = START_TIME;

		//Counters to track the current state of the co-simulation
		int fmusUnloaded = 0;

		//***********************************************************************************************************
		//Scenario Dependent - Should be changed!

		//Number of internal connections - both init and normal
		const int nInternal := 3;
		const int nInternalInit := 3;

		//Number of external connections in scenario
		const int nExternal := 8;

		//The initial of value of h
		int h := H_max;

		//This array is representing the variables of the stepSize that each FMU can take - H_max is the default value
		int stepVariables[nFMU] = {H_max,H_max,H_max,H_max};

		//Encoding of the scenario
		//Each FMU should have a different ID \in [0, nFMU-1]
		
		const int env := 0;
		
		const int load := 1;
		
		const int ctrl := 2;
		
		const int plant := 3;
		

		//Number of inputs and outputs of each FMU
		
		const int env_input := 0;
		const int env_output := 2;
		
		const int load_input := 1;
		const int load_output := 3;
		
		const int ctrl_input := 3;
		const int ctrl_output := 1;
		
		const int plant_input := 4;
		const int plant_output := 2;
		

		//Definition of inputs and outputs of each FMU
		
		// env inputs - 0
			
		// env outputs - 2
			
		const int env_ref := 0;
			
		const int env_psu := 1;
			
		const int env_inputTypes[MaxNInputs] := { noPort,noPort,noPort,noPort };
		
		// load inputs - 1
			
		const int load_f := 0;
			
		// load outputs - 3
			
		const int load_v := 0;
			
		const int load_xaft := 1;
			
		const int load_x := 2;
			
		const int load_inputTypes[MaxNInputs] := { delayed,noPort,noPort,noPort };
		
		// ctrl inputs - 3
			
		const int ctrl_ref := 0;
			
		const int ctrl_w := 1;
			
		const int ctrl_xaft := 2;
			
		// ctrl outputs - 1
			
		const int ctrl_o := 0;
			
		const int ctrl_inputTypes[MaxNInputs] := { delayed,delayed,delayed,noPort };
		
		// plant inputs - 4
			
		const int plant_x := 0;
			
		const int plant_v := 1;
			
		const int plant_o := 2;
			
		const int plant_psu := 3;
			
		// plant outputs - 2
			
		const int plant_w := 0;
			
		const int plant_f := 1;
			
		const int plant_inputTypes[MaxNInputs] := { reactive,reactive,delayed,reactive };
		

		//This array is to keep track of the value of each output port - each output port needs two variables (current and future)
		// and each variable is having two values (defined and time)
		variable connectionVariable[nFMU][MaxNOutputs][2] = { {{{undefined,0}, {undefined,0}},{{undefined,0}, {undefined,0}},{{undefined,0}, {undefined,0}}},{{{undefined,0}, {undefined,0}},{{undefined,0}, {undefined,0}},{{undefined,0}, {undefined,0}}},{{{undefined,0}, {undefined,0}},{{undefined,0}, {undefined,0}},{{undefined,0}, {undefined,0}}},{{{undefined,0}, {undefined,0}},{{undefined,0}, {undefined,0}},{{undefined,0}, {undefined,0}}} };

		//Connections - do not longer contain the type of the input - but it is still a 1:1 mapping
		ExternalConnection external[nExternal] = { {env, env_psu, plant, plant_psu},{env, env_ref, ctrl, ctrl_ref},{load, load_xaft, ctrl, ctrl_xaft},{ctrl, ctrl_o, plant, plant_o},{plant, plant_w, ctrl, ctrl_w},{load, load_x, plant, plant_x},{load, load_v, plant, plant_v},{plant, plant_f, load, load_f} };

		InternalConnection feedthrough[nInternal] = { {plant, plant_v, plant_w},{plant, plant_v, plant_f},{plant, plant_x, plant_f} };

		//The initial internal connection could be different from the connection in the simulation and should be represented differently
		InternalConnection feedthroughInit[nInternalInit] = { {plant, plant_v, plant_w},{plant, plant_v, plant_f},{plant, plant_x, plant_f} };

		//The array show if an FMU can reject a step or not - if the FMU can reject a step the value is 1 on the index defined by the fmus
		const bool mayRejectStep[nFMU] = { false,false,false,false };

		//Numbers of operations in each step
		const int nInstantiation := 8;
		const int nInitialization := 24;
		const int nSimStep := 20;
		const int nLoopOperations := 1;
		const int nFix := 1;
		const int nFindStep := 1;
		const int nConverge := 1;
		const int nTermination := 12;
		const int nRestore := 1;

		//Operations to be performed per loop
		const int[0,nConverge] convergencePorts[nLoops] = {0};
		const int[0,nLoopOperations] loopOps[nLoops] = {0};
		const int[0,nFix] fixOps[nLoops] = {0};

		//The operations is defining what should be performed in the simulation - it is assumed that the operation first loads the fmus
		Operation instantiation[nInstantiation] = { {env, instantiate, noPort, noStep, noCommitment, noLoop},{load, instantiate, noPort, noStep, noCommitment, noLoop},{ctrl, instantiate, noPort, noStep, noCommitment, noLoop},{plant, instantiate, noPort, noStep, noCommitment, noLoop},{env, setupExperiment, noPort, noStep, noCommitment, noLoop},{load, setupExperiment, noPort, noStep, noCommitment, noLoop},{ctrl, setupExperiment, noPort, noStep, noCommitment, noLoop},{plant, setupExperiment, noPort, noStep, noCommitment, noLoop} };

		Operation initialization[nInitialization] = { {env, enterInitialization, noPort, noStep, noCommitment, noLoop},{load, enterInitialization, noPort, noStep, noCommitment, noLoop},{ctrl, enterInitialization, noPort, noStep, noCommitment, noLoop},{plant, enterInitialization, noPort, noStep, noCommitment, noLoop},{env, get, env_psu, noStep, final, noLoop},{plant, set, plant_psu, noStep, final, noLoop},{env, get, env_ref, noStep, final, noLoop},{ctrl, set, ctrl_ref, noStep, final, noLoop},{load, get, load_xaft, noStep, final, noLoop},{ctrl, set, ctrl_xaft, noStep, final, noLoop},{ctrl, get, ctrl_o, noStep, final, noLoop},{plant, set, plant_o, noStep, final, noLoop},{load, get, load_x, noStep, final, noLoop},{plant, set, plant_x, noStep, final, noLoop},{load, get, load_v, noStep, final, noLoop},{plant, set, plant_v, noStep, final, noLoop},{plant, get, plant_w, noStep, final, noLoop},{ctrl, set, ctrl_w, noStep, final, noLoop},{plant, get, plant_f, noStep, final, noLoop},{load, set, load_f, noStep, final, noLoop},{env, exitInitialization, noPort, noStep, noCommitment, noLoop},{load, exitInitialization, noPort, noStep, noCommitment, noLoop},{ctrl, exitInitialization, noPort, noStep, noCommitment, noLoop},{plant, exitInitialization, noPort, noStep, noCommitment, noLoop} };

		Operation simulationStep[nSimStep] = { {ctrl, get, ctrl_o, noStep, final, noLoop},{env, get, env_ref, noStep, final, noLoop},{env, step, noPort, 1, noCommitment, noLoop},{env, get, env_psu, noStep, final, noLoop},{load, step, noPort, 1, noCommitment, noLoop},{load, get, load_x, noStep, final, noLoop},{load, get, load_v, noStep, final, noLoop},{plant, set, plant_v, noStep, final, noLoop},{load, get, load_xaft, noStep, final, noLoop},{plant, set, plant_x, noStep, final, noLoop},{plant, set, plant_psu, noStep, final, noLoop},{ctrl, set, ctrl_ref, noStep, final, noLoop},{ctrl, step, noPort, 1, noCommitment, noLoop},{plant, set, plant_o, noStep, final, noLoop},{plant, step, noPort, 1, noCommitment, noLoop},{plant, get, plant_w, noStep, final, noLoop},{ctrl, set, ctrl_w, noStep, final, noLoop},{plant, get, plant_f, noStep, final, noLoop},{load, set, load_f, noStep, final, noLoop},{ctrl, set, ctrl_xaft, noStep, final, noLoop} };

		//These are the operations to be performed in order to find the correct step
		//In these operation there is a difference on the third parameter to doStep:
		//    H (A step-value greater than the allowed step (Greater than the number of FMUS)) means that we should look at the variable h
		//    A stepSize (0:(nFMU-1)) means that the should look at that index in stepVariables use that as the step
		//This is being done inside - findStepAction

		Operation findStepIteration[nFindStep] = {{noFMU, noOp, noPort, noStep, noCommitment, noLoop}};
		Operation StepFix[nRestore] = {{noFMU, noOp, noPort, noStep, noCommitment, noLoop}};

		//Possible multiple loops
		//Loop operations are to solve algebraic loops in the co-simulation scenario
		Operation loopOperations[nLoops][nLoopOperations] = { { {noFMU, noOp, noPort, noStep, noCommitment, noLoop} } };

		//The converge ports is too mark which variables that needs too be checked in the convergence loop
		//The convention is now to specify the FMU first and the port to denote the variables that should be checked
		FmuOutputPort convergePorts[nLoops][nConverge] = { { { 0, 0 } } };

		Operation loopFixOperations[nLoops][nFix] = { { {noFMU, noOp, noPort, noStep, noCommitment, noLoop} } };

		Operation terminationOperations[nTermination] = { {env, terminate, noPort, noStep, noCommitment, noLoop},{load, terminate, noPort, noStep, noCommitment, noLoop},{ctrl, terminate, noPort, noStep, noCommitment, noLoop},{plant, terminate, noPort, noStep, noCommitment, noLoop},{env, freeInstance, noPort, noStep, noCommitment, noLoop},{load, freeInstance, noPort, noStep, noCommitment, noLoop},{ctrl, freeInstance, noPort, noStep, noCommitment, noLoop},{plant, freeInstance, noPort, noStep, noCommitment, noLoop},{env, unload, noPort, noStep, noCommitment, noLoop},{load, unload, noPort, noStep, noCommitment, noLoop},{ctrl, unload, noPort, noStep, noCommitment, noLoop},{plant, unload, noPort, noStep, noCommitment, noLoop} };

		</declaration>
			<template>
				<name>Interpreter</name>
				<declaration>
					int inst_pc := 0;
					int init_pc := 0;
					int cosimstep_pc := 0;
					int terminate_pc := 0;

					int i;

					//The activeFMU variable dictates which FMU is enabled - which FMU should take an action
					int[-1, nFMU] activeFMU = 0;

					void selectNextInstAction(){
							//action to be performed
							action := instantiation[inst_pc].act;
							//fmu to perform the action
							activeFMU := instantiation[inst_pc].FMU;
							//The variable involved
							var := instantiation[inst_pc].portVariable;

						//Proceed to next action
						inst_pc++;
					}

					void selectNextInitAction(){
					   //action to be performed
					   action := initialization[init_pc].act;
					   //fmu to perform initialization action
					   activeFMU := initialization[init_pc].FMU;
					   //The variable involved
					   var := initialization[init_pc].portVariable;
						loopActive := initialization[init_pc].loop;

						//Proceed to next action
						init_pc++;
					}


					void selectNextCosimStepAction(){
						if(cosimstep_pc &lt; nSimStep){
							//action to be performed
							action := simulationStep[cosimstep_pc].act;
							//fmu to perform the action
							activeFMU := simulationStep[cosimstep_pc].FMU;
							//The variable involved
							var := simulationStep[cosimstep_pc].portVariable;
							//The Stepsize
							stepsize := simulationStep[cosimstep_pc].step_size;
							//The commitment
							commitment := simulationStep[cosimstep_pc].commitment;
							loopActive := simulationStep[cosimstep_pc].loop;

							if(action == step){
								//H (A step-value greater than the allowed step (Greater than the number of FMUS)) means that we should look at the variable h
								if(stepsize == H){
								stepsize := h;
								}else if(stepsize &gt; nFMU){
									//A stepSize (0:(nFMU-1)) means that the should look at that index in stepVariables use that as the step
									stepsize := stepVariables[stepsize];
								}
							}
						}

						//Proceed to next action
						cosimstep_pc++;
					}

					void findFMUTerminateAction(){
						//action to be performed
						action := terminationOperations[terminate_pc].act;
						//fmu to perform the action
						activeFMU := terminationOperations[terminate_pc].FMU;

						//Proceed to next action
						terminate_pc++;
					}

					void takeStep(){
						//h is the time of the step
						time := time + h;
						//Reset the loop actions
						cosimstep_pc := 0;

						//reset the step-size to the biggest possible step
						h := H_max;
						//Reset the step found in last iteration
						for(i = 0; i &lt; nFMU; i++){
							stepVariables[i] = h;
						}
					}
				</declaration>
		<location id="id0" x="841" y="-102">
		</location>
		<location id="id1" x="2091" y="-127">
			<name x="2142" y="-152">Error</name>
		</location>
		<location id="id2" x="1768" y="25">
			<name x="1708" y="68">SolveAlgebraicLoop</name>
		</location>
		<location id="id3" x="1785" y="-221">
			<name x="1775" y="-255">FindStep</name>
		</location>
		<location id="id4" x="1105" y="-102">
			<name x="1079" y="-144">CosimStep</name>
			<committed/>
		</location>
		<location id="id5" x="1241" y="-425">
			<name x="1147" y="-484">NormalFMUAction</name>
		</location>
		<location id="id6" x="561" y="416">
			<name x="578" y="408">Terminated</name>
		</location>
		<location id="id7" x="561" y="272">
			<committed/>
		</location>
		<location id="id8" x="952" y="272">
			<name x="944" y="306">Termination</name>
			<committed/>
		</location>
		<location id="id9" x="1394" y="-102">
			<name x="1411" y="-68">Simulate</name>
			<committed/>
		</location>
		<location id="id10" x="569" y="-102">
			<committed/>
		</location>
		<location id="id11" x="339" y="-102">
			<name x="501" y="-357">Initialization</name>
			<committed/>
		</location>
		<location id="id12" x="-174" y="-102">
			<name x="-139" y="-340">Instantiation</name>
			<committed/>
		</location>
		<location id="id13" x="107" y="-102">
		</location>
		<location id="id14" x="-459" y="-102">
			<name x="-469" y="-136">Start</name>
			<committed/>
		</location>
		<init ref="id14"/>
		<transition>
			<source ref="id0"/>
			<target ref="id10"/>
			<label kind="guard" x="586" y="-314">init_pc &lt; nInitialization</label>
			<label kind="synchronisation" x="587" y="-297">actionPerformed?</label>
			<label kind="assignment" x="586" y="-280">selectNextInitAction()</label>
			<nail x="841" y="-280"/>
			<nail x="569" y="-280"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id4"/>
			<label kind="guard" x="875" y="-144">init_pc == nInitialization</label>
			<label kind="synchronisation" x="884" y="-127">actionPerformed?</label>
		</transition>
		<transition>
			<source ref="id10"/>
			<target ref="id0"/>
			<label kind="guard" x="603" y="-204">action == get || 
action == set || 
action == exitInitialization ||
action == enterInitialization</label>
			<label kind="synchronisation" x="587" y="-123">fmu[activeFMU]!</label>
		</transition>
		<transition>
			<source ref="id11"/>
			<target ref="id10"/>
			<label kind="assignment" x="357" y="-102">selectNextInitAction()</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id11"/>
			<label kind="guard" x="127" y="-136">inst_pc ==nInstantiation</label>
			<label kind="synchronisation" x="135" y="-119">actionPerformed?</label>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="1895" y="-17">ErrorChan?</label>
			<nail x="2091" y="25"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id1"/>
			<label kind="synchronisation" x="1980" y="-255">ErrorChan?</label>
			<nail x="2091" y="-221"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id4"/>
			<label kind="guard" x="1139" y="-34">cosimstep_pc == nSimStep + 1
&amp;&amp; time &lt; end</label>
			<label kind="assignment" x="1190" y="8">takeStep()</label>
			<nail x="1258" y="-42"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="1504" y="-26">solveLoop?</label>
			<label kind="assignment" x="1521" y="8">selectNextCosimStepAction()</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id2"/>
			<label kind="guard" x="1623" y="-93">loopActive != -1 
&amp;&amp; action == loop</label>
			<label kind="synchronisation" x="1538" y="-127">solveLoop!</label>
			<nail x="1785" y="-110"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="1581" y="-416">findStepChan?</label>
			<label kind="assignment" x="1581" y="-391">selectNextCosimStepAction(), 
stepFinderActive := false</label>
			<nail x="1666" y="-365"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id3"/>
			<label kind="guard" x="1564" y="-221">action == findStep</label>
			<label kind="synchronisation" x="1725" y="-170">findStepChan!</label>
			<label kind="assignment" x="1717" y="-195">stepFinderActive := true</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id9"/>
			<label kind="assignment" x="1139" y="-187">selectNextCosimStepAction()</label>
			<nail x="1249" y="-161"/>
		</transition>
		<transition>
			<source ref="id6"/>
			<target ref="id6"/>
			<nail x="442" y="476"/>
			<nail x="442" y="391"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="1351" y="-493">actionPerformed?</label>
			<label kind="assignment" x="1351" y="-467">selectNextCosimStepAction()</label>
			<nail x="1436" y="-442"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id5"/>
			<label kind="guard" x="1054" y="-382">(action == get ||
action == set || 
action == step || 
action == save ||
action == restore)
&amp;&amp; cosimstep_pc &lt; (nSimStep +1)</label>
			<label kind="synchronisation" x="1190" y="-255">fmu[activeFMU]!</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="guard" x="578" y="120">terminate_pc &lt; nTermination</label>
			<label kind="assignment" x="680" y="86">findFMUTerminateAction()</label>
			<nail x="561" y="153"/>
			<nail x="952" y="153"/>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id6"/>
			<label kind="guard" x="570" y="332">terminate_pc == nTermination</label>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="guard" x="655" y="187">action == unload ||
action == freeInstance ||
action == terminate</label>
			<label kind="synchronisation" x="697" y="247">fmu[activeFMU]!</label>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id8"/>
			<label kind="guard" x="1156" y="102">cosimstep_pc == nSimStep + 1
&amp;&amp; time &gt;= end</label>
			<label kind="assignment" x="1156" y="161">findFMUTerminateAction()</label>
			<nail x="1402" y="272"/>
		</transition>
		<transition>
			<source ref="id12"/>
			<target ref="id13"/>
			<label kind="guard" x="-120" y="-93">action == instantiate || 
action == setParameter ||
action == setupExperiment</label>
			<label kind="synchronisation" x="-106" y="-127">fmu[activeFMU]!</label>
		</transition>
		<transition>
			<source ref="id13"/>
			<target ref="id12"/>
			<label kind="guard" x="-156" y="-297">inst_pc &lt; nInstantiation</label>
			<label kind="synchronisation" x="-156" y="-280">actionPerformed?</label>
			<label kind="assignment" x="-127" y="-263">selectNextInstAction()</label>
			<nail x="107" y="-263"/>
			<nail x="-174" y="-263"/>
		</transition>
		<transition>
			<source ref="id14"/>
			<target ref="id12"/>
			<label kind="assignment" x="-383" y="-102">selectNextInstAction()</label>
		</transition>
	</template>
	<template>
		<name>LoopSolver</name>
		<parameter>int maxIteration</parameter>
		<declaration>
			int convergence_pc := 0;
			int restore_pc := 0;

			//The activeFMU variable dictates which FMU is enabled - which FMU should take an action
			int[0, nFMU] activeFMU = 0;

			//Number of iteration run in the loop Solver
			int currentConvergeLoopIteration := 0;

			//for index
			int i := 0;


			void selectNextLoopAction(int l){
					//action to be performed
					action := loopOperations[l][convergence_pc].act;
					//fmu to perform the action
					activeFMU := loopOperations[l][convergence_pc].FMU;
					//The variable involved
					var := loopOperations[l][convergence_pc].portVariable;
					//The Commit of the port
					commitment := loopOperations[l][convergence_pc].commitment;
					stepsize := loopOperations[l][convergence_pc].step_size;
					if(action == step){
						//H (A step-value greater than the allowed step (Greater than the number of FMUS)) means that we should look at the variable h
						if(stepsize == H){
							var := h;
						}else if(stepsize &gt; nFMU){
							//A stepSize (0:(nFMU-1)) means that the should look at that index in stepVariables use that as the step
							stepsize := stepVariables[stepsize];
						}
					}


				//Proceed to next acction
				convergence_pc ++;
			}

			void selectNextRestoreAction(int l){
				//action to be performed
				action := loopFixOperations[l][restore_pc].act;
				//fmu to perform the action
				activeFMU := loopFixOperations[l][restore_pc].FMU;

				restore_pc++;
			}


			void updateConvergenceVariables(int l){
				int fmu;
				int v;
				for(i = 0; i &lt; convergencePorts[l]; i++){
					fmu = convergePorts[l][i].FMU;
					v = convergePorts[l][i].port;
					connectionVariable[fmu][v][final].status := connectionVariable[fmu][v][tentative].status;
					connectionVariable[fmu][v][final].time := connectionVariable[fmu][v][tentative].time;
				}
			}

			void loopConverge(){
				//Loop not longer active
				loopActive := -1;
				//Loop action counter reset
				convergence_pc := 0;
				//Reset convergence counter
				currentConvergeLoopIteration := 0;
			}


			void resetConvergenceloop(){
				convergence_pc := 0;
				restore_pc := 0;
				selectNextLoopAction(loopActive);
			}

			//Convergence will happen when all convergenceVariables have a similar future and current value
			bool convergenceCriteria(int l){
				return forall(x:int[0,nConverge-1]) convergePorts[l][x].FMU != noFMU imply connectionVariable[convergePorts[l][x].FMU][convergePorts[l][x].port][final].status == connectionVariable[convergePorts[l][x].FMU][convergePorts[l][x].port][tentative].status
					&amp;&amp; connectionVariable[convergePorts[l][x].FMU][convergePorts[l][x].port][final].time == connectionVariable[convergePorts[l][x].FMU][convergePorts[l][x].port][tentative].time;
			}

			bool convergence(int l){
				return (convergenceCriteria(l) &amp;&amp; isLoopExtraIteration);
			}


			void updateIsExtra(int l){
				if(convergenceCriteria(l)){
					isLoopExtraIteration := true;
				}
			}
		</declaration>
		<location id="id15" x="-1011" y="-518">
			<committed/>
		</location>
		<location id="id16" x="-1079" y="-663">
		</location>
		<location id="id17" x="-442" y="-824">
			<name x="-494" y="-858">NotConverging</name>
		</location>
		<location id="id18" x="-484" y="-255">
			<name x="-433" y="-221">UpdateVariables</name>
			<committed/>
		</location>
		<location id="id19" x="-17" y="-518">
		</location>
		<location id="id20" x="-340" y="-518">
			<name x="-332" y="-509">RestoreState</name>
			<committed/>
		</location>
		<location id="id21" x="-739" y="-518">
			<name x="-714" y="-543">CheckConvergence</name>
			<committed/>
		</location>
		<location id="id22" x="-1088" y="-357">
		</location>
		<location id="id23" x="-1343" y="-518">
			<committed/>
		</location>
		<location id="id24" x="-1708" y="-518">
		</location>
		<init ref="id24"/>
		<transition>
			<source ref="id15"/>
			<target ref="id23"/>
			<label kind="guard" x="-1291" y="-548">convergence_pc &lt; loopOps[loopActive]</label>
			<label kind="assignment" x="-1283" y="-510">selectNextLoopAction(loopActive)</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id16"/>
			<label kind="guard" x="-1292" y="-646">action == findStep</label>
			<label kind="synchronisation" x="-1317" y="-612">findStepChan!</label>
			<label kind="assignment" x="-1334" y="-680">isStepNested := true</label>
		</transition>
		<transition>
			<source ref="id15"/>
			<target ref="id21"/>
			<label kind="guard" x="-1011" y="-552">convergence_pc == loopOps[loopActive]</label>
			<label kind="assignment" x="-993" y="-518">currentConvergeLoopIteration++</label>
		</transition>
		<transition>
			<source ref="id16"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-1011" y="-612">findStepChan?</label>
			<label kind="assignment" x="-1020" y="-586">isStepNested = false</label>
		</transition>
		<transition>
			<source ref="id22"/>
			<target ref="id15"/>
			<label kind="synchronisation" x="-1020" y="-433">actionPerformed?</label>
		</transition>
		<transition>
			<source ref="id23"/>
			<target ref="id22"/>
			<label kind="guard" x="-1249" y="-374">action == get ||
action == set || 
action == step || 
action == restore</label>
			<label kind="synchronisation" x="-1282" y="-403">fmu[activeFMU]!</label>
		</transition>
		<transition>
			<source ref="id18"/>
			<target ref="id23"/>
			<label kind="assignment" x="-1402" y="-212">updateConvergenceVariables(loopActive),
resetConvergenceloop()</label>
			<nail x="-1309" y="-246"/>
			<nail x="-1343" y="-246"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id17"/>
			<label kind="guard" x="-816" y="-867">!convergence(loopActive) &amp;&amp;
currentConvergeLoopIteration == maxIteration</label>
			<label kind="synchronisation" x="-646" y="-892">ErrorChan!</label>
			<nail x="-671" y="-628"/>
			<nail x="-671" y="-824"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id18"/>
			<label kind="guard" x="-229" y="-306">restore_pc == fixOps[loopActive]</label>
			<label kind="synchronisation" x="-221" y="-280">actionPerformed?</label>
			<nail x="-17" y="-255"/>
		</transition>
		<transition>
			<source ref="id19"/>
			<target ref="id20"/>
			<label kind="guard" x="-272" y="-731">restore_pc &lt; fixOps[loopActive]</label>
			<label kind="synchronisation" x="-272" y="-705">actionPerformed?</label>
			<label kind="assignment" x="-297" y="-663">selectNextRestoreAction(loopActive)</label>
			<nail x="-17" y="-680"/>
			<nail x="-340" y="-680"/>
		</transition>
		<transition>
			<source ref="id20"/>
			<target ref="id19"/>
			<label kind="synchronisation" x="-247" y="-552">fmu[activeFMU]!</label>
			<nail x="-213" y="-518"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id24"/>
			<label kind="guard" x="-1249" y="-816">convergence(loopActive)</label>
			<label kind="synchronisation" x="-1071" y="-816">solveLoop!</label>
			<label kind="assignment" x="-1385" y="-859">loopConverge(), 
isLoopExtraIteration:= false</label>
			<nail x="-739" y="-790"/>
			<nail x="-1105" y="-790"/>
			<nail x="-1708" y="-790"/>
		</transition>
		<transition>
			<source ref="id21"/>
			<target ref="id20"/>
			<label kind="guard" x="-671" y="-586">!convergence(loopActive) &amp;&amp; 
currentConvergeLoopIteration &lt; maxIteration</label>
			<label kind="assignment" x="-663" y="-510">selectNextRestoreAction(loopActive),
updateIsExtra(loopActive)</label>
		</transition>
		<transition>
			<source ref="id24"/>
			<target ref="id23"/>
			<label kind="guard" x="-1581" y="-569">loopActive != -1 
&amp;&amp; action == loop</label>
			<label kind="synchronisation" x="-1505" y="-536">solveLoop?</label>
			<label kind="assignment" x="-1632" y="-493">selectNextLoopAction(loopActive),
currentConvergeLoopIteration := 0</label>
			<nail x="-1377" y="-518"/>
		</transition>
	</template>
	<template>
		<name>StepFinder</name>
		<parameter>int maxTries</parameter>
		<declaration>
			int step_pc := 0;
			int restore_pc := 0;
			int numbersOfTries := 0;

			//The activeFMU variable dictates which FMU is enabled - which FMU should take an action
			int[0, nFMU] activeFMU = 0;


			void selectNextStepFinderAction(){
				//action to be performed
				action := findStepIteration[step_pc].act;
				//fmu to perform the action
				activeFMU := findStepIteration[step_pc].FMU;
				//The variable involved
				var := findStepIteration[step_pc].portVariable;
				commitment := findStepIteration[step_pc].commitment;
				stepsize := findStepIteration[step_pc].step_size;
				loopActive := findStepIteration[step_pc].loop;

				if(action == step){
					//H (A step-value greater than the allowed step (Greater than the number of FMUS)) means that we should look at the variable h
					if(stepsize == H){
						stepsize := h;
					}else if(stepsize &gt; nFMU){
						//A stepSize (0:(nFMU-1)) means that the should look at that index in stepVariables use that as the step
							stepsize := stepVariables[stepsize];
					}
				}

				step_pc++;
			}

			void selectNextStepRestoreAction(){
				//action to be performed
				action := StepFix[restore_pc].act;
				//fmu to perform the action
				activeFMU := StepFix[restore_pc].FMU;
				restore_pc++;
			}

			void findMinStep(){
				//Maximum step size allowed
				int min = nFMU;
				int j := 0;
				for(j = 0; j &lt; nFMU; j++){
					if(stepVariables[j] &lt; min){
						min := stepVariables[j];
					}
				}
				h := min;
			}


			bool stepFound(){
				//All FMU that may reject a step should be able to take the same step - h
				return forall(x:int[0, nFMU-1]) mayRejectStep[x] imply stepVariables[x] == h;
			}

			bool loopConverged(){
				return (stepFound() &amp;&amp; isStepExtraIteration);
			}


			void updateIsExtra(){
				if(stepFound()){
					isStepExtraIteration := true;
					//Reset numbers of tries to 1 - This is to avoid problems with the maximum number of tries and not to active the nested checks
					if(numbersOfTries &gt; 2){
						numbersOfTries := 1;
					}
				}
			}
		</declaration>
		<location id="id25" x="1122" y="-178">
			<committed/>
		</location>
		<location id="id26" x="-773" y="-178">
			<committed/>
		</location>
		<location id="id27" x="-34" y="-178">
			<committed/>
		</location>
		<location id="id28" x="-144" y="17">
		</location>
		<location id="id29" x="817" y="144">
			<committed/>
		</location>
		<location id="id30" x="654" y="-578">
			<name x="644" y="-612">NoCommonStep</name>
		</location>
		<location id="id31" x="-1427" y="-178">
			<name x="-1478" y="-187">Start</name>
		</location>
		<location id="id32" x="-935" y="-331">
		</location>
		<location id="id33" x="-1138" y="-178">
			<name x="-1198" y="-323">DrawStepSize</name>
			<committed/>
		</location>
		<location id="id34" x="1011" y="-331">
		</location>
		<location id="id35" x="732" y="-178">
			<name x="681" y="-237">Reset</name>
			<committed/>
		</location>
		<location id="id36" x="348" y="-178">
			<committed/>
		</location>
		<location id="id37" x="-144" y="-382">
		</location>
		<location id="id38" x="-510" y="-178">
			<committed/>
		</location>
		<init ref="id31"/>
		<transition>
			<source ref="id25"/>
			<target ref="id29"/>
			<label kind="guard" x="884" y="110">nRestore == restore_pc</label>
			<nail x="1147" y="-178"/>
			<nail x="1147" y="144"/>
		</transition>
		<transition>
			<source ref="id25"/>
			<target ref="id35"/>
			<label kind="guard" x="892" y="-212">restore_pc &lt; nRestore</label>
			<label kind="assignment" x="901" y="-170">selectNextStepRestoreAction()</label>
		</transition>
		<transition>
			<source ref="id34"/>
			<target ref="id25"/>
			<label kind="synchronisation" x="1062" y="-289">actionPerformed?</label>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id26"/>
			<label kind="guard" x="-1054" y="-25">activeFMU &lt; nFMU &amp;&amp;
!mayRejectStep[activeFMU]</label>
			<label kind="assignment" x="-1122" y="-76">activeFMU++</label>
			<nail x="-952" y="-59"/>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id33"/>
			<label kind="guard" x="-1045" y="-212">activeFMU &lt; nFMU</label>
		</transition>
		<transition>
			<source ref="id32"/>
			<target ref="id26"/>
			<label kind="synchronisation" x="-841" y="-306">actionPerformed?</label>
		</transition>
		<transition>
			<source ref="id26"/>
			<target ref="id38"/>
			<label kind="guard" x="-747" y="-216">activeFMU == nFMU</label>
			<label kind="assignment" x="-747" y="-182">selectNextStepFinderAction()</label>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id38"/>
			<label kind="guard" x="-365" y="-212">step_pc &lt; nFindStep</label>
			<label kind="assignment" x="-416" y="-178">selectNextStepFinderAction()</label>
		</transition>
		<transition>
			<source ref="id28"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-51" y="-85">solveLoop?</label>
			<label kind="assignment" x="-102" y="-51">isLoopNested := false</label>
		</transition>
		<transition>
			<source ref="id27"/>
			<target ref="id36"/>
			<label kind="guard" x="-16" y="-212">nFindStep == step_pc</label>
			<label kind="assignment" x="110" y="-161">findMinStep(),
numbersOfTries++</label>
		</transition>
		<transition>
			<source ref="id37"/>
			<target ref="id27"/>
			<label kind="synchronisation" x="-85" y="-323">actionPerformed?</label>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id28"/>
			<label kind="guard" x="-459" y="-51">action == loop</label>
			<label kind="synchronisation" x="-459" y="-76">solveLoop!</label>
			<label kind="assignment" x="-442" y="8">isLoopNested := true</label>
		</transition>
		<transition>
			<source ref="id29"/>
			<target ref="id38"/>
			<label kind="assignment" x="-459" y="170">step_pc := 0, restore_pc := 0, selectNextStepFinderAction()</label>
			<nail x="-510" y="153"/>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id30"/>
			<label kind="guard" x="407" y="-561">!stepFound() &amp;&amp;
numbersOfTries == maxTries</label>
			<label kind="synchronisation" x="484" y="-510">ErrorChan!</label>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id31"/>
			<label kind="guard" x="-1258" y="-748">loopConverged()</label>
			<label kind="synchronisation" x="-1258" y="-722">findStepChan!</label>
			<label kind="assignment" x="-1258" y="-688">step_pc := 0, isStepExtraIteration := false, restore_pc:=0</label>
			<nail x="76" y="-612"/>
			<nail x="-1428" y="-612"/>
		</transition>
		<transition>
			<source ref="id31"/>
			<target ref="id33"/>
			<label kind="synchronisation" x="-1308" y="-212">findStepChan?</label>
			<label kind="assignment" x="-1394" y="-161">activeFMU := 0, 
numbersOfTries := 0</label>
		</transition>
		<transition>
			<source ref="id33"/>
			<target ref="id32"/>
			<label kind="guard" x="-1156" y="-365">mayRejectStep[activeFMU]</label>
			<label kind="synchronisation" x="-1113" y="-340">fmu[activeFMU]!</label>
			<label kind="assignment" x="-1139" y="-289">activeFMU++</label>
		</transition>
		<transition>
			<source ref="id35"/>
			<target ref="id34"/>
			<label kind="synchronisation" x="782" y="-348">fmu[activeFMU]!</label>
		</transition>
		<transition>
			<source ref="id36"/>
			<target ref="id35"/>
			<label kind="guard" x="416" y="-221">!loopConverged() &amp;&amp;
numbersOfTries &lt; maxTries</label>
			<label kind="assignment" x="433" y="-161">activeFMU := 0,
updateIsExtra()</label>
		</transition>
		<transition>
			<source ref="id38"/>
			<target ref="id37"/>
			<label kind="guard" x="-467" y="-382">action == get ||
action == set || 
action == step || 
action == restore</label>
			<label kind="synchronisation" x="-484" y="-289">fmu[activeFMU]!</label>
		</transition>
	</template>
	<template>
		<name>FMU</name>
		<parameter>int id, int nOutput, int nInput, int inputType[MaxNInputs]</parameter>
		<declaration>
			int cTime := START_TIME;
			//The variables is a 2D array - the first item is if the variable is defined and the second is the time where it was defined
			variable inputVariables[MaxNInputs] = { {defined,0},{defined,0},{defined,0},{defined,0} };
			variable outputVariables[MaxNOutputs]  = { {defined,0},{defined,0},{defined,0} };
			bool initialized := false;
			bool simulated := false;

			//Index for the for-loop
			int i := 0;

			//Default maximum step size
			int[1,H_max] maxStepSize := nFMU;

			//Backup state
			variable savedOutputVariables[MaxNOutputs];
			variable savedInputVariables[MaxNInputs];
			int savedTime;
			bool isSaved := false;

			bool isConsistent := true;

			void initialize(){
				initialized := true;
				//Set all variables to undefined
				for(i = 0; i &lt; nInput; i++){
					inputVariables[i].status := undefined;
					inputVariables[i].time := 0;
				}
				for(i := 0; i &lt; nOutput; i++){
					outputVariables[i].status := undefined;
					outputVariables[i].time := 0;
				}
			}

			void simulate(){
				simulated := true;
			}

			void setStepSize(int r){
				maxStepSize := r;
			}

			void getValue(int v, int a){
				outputVariables[v].status := defined;
				outputVariables[v].time := cTime;
				
				connectionVariable[id][v][a].status := defined;
				connectionVariable[id][v][a].time := cTime;
			}

			void setValue(int v, int a){
				inputVariables[v].status := defined;
				for(i = 0; i &lt; nExternal; i++){
					if(external[i].TrgFMU == id &amp;&amp; external[i].input == v){
						inputVariables[v].time := connectionVariable[external[i].SrcFMU][external[i].output][a].time;
					}
				}
			}

			//Proceed in time - we will start by assuming an FMU can't reject a stepsize
			void doStep(int t){
				//Checking of step is valid
				if(t &gt; maxStepSize){
				   //Step is too big and will not be allowed - t is reset too the biggest allowed step
				   t := maxStepSize;
				}

				//Take step
				cTime := cTime + t;

				isConsistent := true;

				for(i = 0; i &lt; nInput; i++){
					if(inputVariables[i].time != cTime){
						isConsistent := false;
					}
				}

				//Reset outputs accesssed and advance their timestamp
				for(i = 0; i &lt; nOutput; i++){
					//The inputs of the FMUs are inconsistent (not all are at time cTime) - so the FMUs output valid should be set to NaN
					if(isConsistent){
						outputVariables[i].status := undefined;
						outputVariables[i].time := cTime;
					}else{
						outputVariables[i].status := notStable;
						outputVariables[i].time := cTime;
					}
				}

				isConsistent := true;

				//Update or return the taken step size
				stepVariables[id] := t;
			}

			void restoreState(){
				outputVariables := savedOutputVariables;
				inputVariables := savedInputVariables;
				cTime := savedTime;
			}

			void saveState(){
				savedOutputVariables := outputVariables;
				savedInputVariables := inputVariables;
				savedTime := cTime;
				isSaved := true;
			}

			bool preSetInit(int v, int a){
				//All outputs connected to the input should be defined - no difference between delay and reactive in init. ConnectionVariables an d ExternalConnections are having the same order
				return forall(x:int[0, nExternal-1]) external[x].TrgFMU == id &amp;&amp; external[x].input == v imply connectionVariable[external[x].SrcFMU][external[x].output][a].status == defined;

			}

			bool preGetInit(int v, int a){
				//The internal time should be equivalent to 0 and all variable connected to this one should be defined 
				return forall(x:int[0, nInternalInit-1]) feedthroughInit[x].FMU == id &amp;&amp; feedthroughInit[x].output == v imply inputVariables[feedthroughInit[x].input].status == defined;
			}


			bool preSet(int v, int a){
				if(shouldChecksBeDisabled()){
					return true;
				}

		    //If the connection is reactive the connected variable needs to have a greater than the time of the FMU and be defined
			return (forall(x:int[0, nExternal-1]) external[x].TrgFMU == id &amp;&amp; external[x].input == v &amp;&amp; inputType[v] == reactive  
					imply connectionVariable[external[x].SrcFMU][external[x].output][a].status == defined &amp;&amp; connectionVariable[external[x].SrcFMU][external[x].output][a].time &gt; cTime) &amp;&amp;
				(forall(x:int[0, nExternal-1]) external[x].TrgFMU == id &amp;&amp; external[x].input == v &amp;&amp; inputType[v] == delayed  
					imply connectionVariable[external[x].SrcFMU][external[x].output][a].status == defined &amp;&amp; connectionVariable[external[x].SrcFMU][external[x].output][a].time == cTime);
			}


			bool preGet(int v){
				if(shouldChecksBeDisabled()){
					return true;
				}

				//All internal connections should be defined at time cTime
			   return forall(x:int[0, nInternal-1]) feedthrough[x].FMU == id &amp;&amp; feedthrough[x].output == v imply inputVariables[feedthrough[x].input].status == defined &amp;&amp; inputVariables[feedthrough[x].input].time == cTime;
			}

			bool preDoStep(int t){
				if(shouldChecksBeDisabled()){
					return true;
				}

				//All delayed input ports should be defined at the current time
				//And all reactive inputs ports should be defined at the next time step
				return (forall(x:int[0, MaxNInputs-1]) inputType[x] == reactive
					imply inputVariables[x].status == defined &amp;&amp; inputVariables[x].time == cTime + t) &amp;&amp;
					(forall(x:int[0, MaxNInputs-1]) inputType[x] == delayed
					imply inputVariables[x].status == defined &amp;&amp; inputVariables[x].time == cTime);
			}

			//An FMU can only enter the Simulation mode when all connected FMU variables are defined at time 0
			bool preSimulation(){
			   return ((forall(x:int[0, MaxNOutputs-1]) outputVariables[x].status == defined &amp;&amp; outputVariables[x].time == 0)
					&amp;&amp; (forall(x:int[0, MaxNInputs-1]) inputVariables[x].status == defined &amp;&amp; inputVariables[x].time == 0));
			}

			bool preSaveState(){
				//Always possible
				return true;
			}

			bool preRestoreState(){
				//Should a requirement be a saved previous state?
				return isSaved;
			}
		</declaration>
		<location id="id39" x="-9588" y="-11305">
			<name x="-9598" y="-11339">Unloaded</name>
		</location>
		<location id="id40" x="-9826" y="-11305">
		</location>
		<location id="id41" x="-11584" y="-11118">
		</location>
		<location id="id42" x="-12034" y="-11118">
			<committed/>
		</location>
		<location id="id43" x="-10752" y="-11305">
			<label kind="invariant" x="-10795" y="-11280">preSimulation()</label>
			<committed/>
		</location>
		<location id="id44" x="-11339" y="-11305">
			<committed/>
		</location>
		<location id="id45" x="-11813" y="-11305">
			<committed/>
		</location>
		<location id="id46" x="-12230" y="-11305">
			<committed/>
		</location>
		<location id="id47" x="-11584" y="-11305">
		</location>
		<location id="id48" x="-12034" y="-11305">
			<name x="-12204" y="-11543">Instantiated</name>
		</location>
		<location id="id49" x="-10574" y="-11109">
			<committed/>
		</location>
		<location id="id50" x="-10463" y="-11092">
			<label kind="invariant" x="-10473" y="-11075">preRestoreState()</label>
			<committed/>
		</location>
		<location id="id51" x="-11058" y="-11186">
			<label kind="invariant" x="-11101" y="-11169">preGetInit(var, commitment)</label>
			<committed/>
		</location>
		<location id="id52" x="-11058" y="-11432">
			<label kind="invariant" x="-11118" y="-11483">preSetInit(var, commitment)</label>
			<committed/>
		</location>
		<location id="id53" x="-12425" y="-11296">
			<name x="-12484" y="-11279">loaded</name>
		</location>
		<location id="id54" x="-10293" y="-11101">
			<label kind="invariant" x="-10250" y="-11109">preSaveState()</label>
			<committed/>
		</location>
		<location id="id55" x="-10192" y="-11500">
			<label kind="invariant" x="-10175" y="-11526">preDoStep(stepsize)</label>
			<committed/>
		</location>
		<location id="id56" x="-10345" y="-11543">
			<label kind="invariant" x="-10379" y="-11585">preGet(var)</label>
			<committed/>
		</location>
		<location id="id57" x="-11058" y="-11305">
			<name x="-11143" y="-11296">Initialize</name>
		</location>
		<location id="id58" x="-10549" y="-11492">
			<label kind="invariant" x="-10617" y="-11551">preSet(var, commitment)</label>
			<committed/>
		</location>
		<location id="id59" x="-10072" y="-11305">
		</location>
		<location id="id60" x="-10387" y="-11305">
			<name x="-10498" y="-11330">Simulation</name>
		</location>
		<init ref="id53"/>
		<transition>
			<source ref="id40"/>
			<target ref="id39"/>
			<label kind="guard" x="-9808" y="-11339">action == unload</label>
			<label kind="synchronisation" x="-9808" y="-11322">fmu[id]?</label>
		</transition>
		<transition>
			<source ref="id59"/>
			<target ref="id40"/>
			<label kind="guard" x="-10030" y="-11339">action == freeInstance</label>
			<label kind="synchronisation" x="-9996" y="-11296">fmu[id]?</label>
		</transition>
		<transition>
			<source ref="id43"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-10693" y="-11322">actionPerformed!</label>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id43"/>
			<label kind="guard" x="-10965" y="-11348">action == exitInitialization</label>
			<label kind="synchronisation" x="-10939" y="-11331">fmu[id]?</label>
			<label kind="assignment" x="-10931" y="-11288">simulate()</label>
		</transition>
		<transition>
			<source ref="id44"/>
			<target ref="id57"/>
			<label kind="synchronisation" x="-11287" y="-11330">actionPerformed!</label>
		</transition>
		<transition>
			<source ref="id47"/>
			<target ref="id44"/>
			<label kind="guard" x="-11559" y="-11356">action == enterInitialization</label>
			<label kind="synchronisation" x="-11542" y="-11331">fmu[id]?</label>
		</transition>
		<transition>
			<source ref="id41"/>
			<target ref="id47"/>
			<label kind="synchronisation" x="-11771" y="-11245">actionPerformed!</label>
			<nail x="-11660" y="-11211"/>
		</transition>
		<transition>
			<source ref="id47"/>
			<target ref="id41"/>
			<label kind="guard" x="-11533" y="-11160">action == setParameter</label>
			<label kind="synchronisation" x="-11516" y="-11186">fmu[id]?</label>
			<nail x="-11507" y="-11211"/>
		</transition>
		<transition>
			<source ref="id42"/>
			<target ref="id48"/>
			<label kind="synchronisation" x="-12255" y="-11169">actionPerformed!</label>
			<nail x="-12136" y="-11211"/>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id42"/>
			<label kind="guard" x="-11958" y="-11152">action == setParameter</label>
			<label kind="synchronisation" x="-11924" y="-11211">fmu[id]?</label>
			<nail x="-11932" y="-11203"/>
		</transition>
		<transition>
			<source ref="id45"/>
			<target ref="id47"/>
			<label kind="synchronisation" x="-11779" y="-11330">actionPerformed!</label>
		</transition>
		<transition>
			<source ref="id48"/>
			<target ref="id45"/>
			<label kind="guard" x="-12000" y="-11339">action == setupExperiment</label>
			<label kind="synchronisation" x="-11992" y="-11288">fmu[id]?</label>
		</transition>
		<transition>
			<source ref="id46"/>
			<target ref="id48"/>
			<label kind="synchronisation" x="-12204" y="-11330">actionPerformed!</label>
		</transition>
		<transition>
			<source ref="id53"/>
			<target ref="id46"/>
			<label kind="guard" x="-12400" y="-11339">action == instantiate</label>
			<label kind="synchronisation" x="-12382" y="-11305">fmu[id]?</label>
			<label kind="assignment" x="-12382" y="-11288">initialize()</label>
		</transition>
		<transition>
			<source ref="id49"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-10599" y="-11194">actionPerformed!</label>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id49"/>
			<label kind="select" x="-10667" y="-11271">selectedStep: int[1, H_max]</label>
			<label kind="guard" x="-10727" y="-11228">action == findStep</label>
			<label kind="synchronisation" x="-10710" y="-11186">fmu[id]?</label>
			<label kind="assignment" x="-10693" y="-11084">setStepSize(selectedStep)</label>
			<nail x="-10659" y="-11186"/>
		</transition>
		<transition>
			<source ref="id50"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-10497" y="-11152">actionPerformed!</label>
			<label kind="assignment" x="-10472" y="-11177">restoreState()</label>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id50"/>
			<label kind="guard" x="-10387" y="-11058">action == restore</label>
			<label kind="synchronisation" x="-10446" y="-11041">fmu[id]?</label>
			<nail x="-10344" y="-11092"/>
		</transition>
		<transition>
			<source ref="id51"/>
			<target ref="id57"/>
			<label kind="synchronisation" x="-11228" y="-11237">actionPerformed!</label>
			<label kind="assignment" x="-11245" y="-11211">getValue(var, commitment)</label>
			<nail x="-11118" y="-11245"/>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id51"/>
			<label kind="guard" x="-10999" y="-11228">action == get</label>
			<label kind="synchronisation" x="-10990" y="-11254">fmu[id]?</label>
			<nail x="-10999" y="-11245"/>
		</transition>
		<transition>
			<source ref="id52"/>
			<target ref="id57"/>
			<label kind="synchronisation" x="-11024" y="-11432">actionPerformed!</label>
			<label kind="assignment" x="-11016" y="-11407">setValue(var, commitment)</label>
			<nail x="-10999" y="-11373"/>
		</transition>
		<transition>
			<source ref="id57"/>
			<target ref="id52"/>
			<label kind="guard" x="-11186" y="-11449">action == set</label>
			<label kind="synchronisation" x="-11160" y="-11424">fmu[id]?</label>
			<nail x="-11118" y="-11381"/>
		</transition>
		<transition>
			<source ref="id54"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-10191" y="-11152">actionPerformed!</label>
			<label kind="assignment" x="-10183" y="-11186">saveState()</label>
			<nail x="-10191" y="-11160"/>
		</transition>
		<transition>
			<source ref="id55"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-10158" y="-11466">actionPerformed!</label>
			<label kind="assignment" x="-10149" y="-11415">doStep(stepsize)</label>
			<nail x="-10132" y="-11373"/>
		</transition>
		<transition>
			<source ref="id56"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-10294" y="-11551">actionPerformed!</label>
			<label kind="assignment" x="-10362" y="-11483">getValue(var, commitment)</label>
			<nail x="-10226" y="-11517"/>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id54"/>
			<label kind="guard" x="-10319" y="-11169">action == save</label>
			<label kind="synchronisation" x="-10319" y="-11203">fmu[id]?</label>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id55"/>
			<label kind="guard" x="-10277" y="-11415">action == step</label>
			<label kind="synchronisation" x="-10294" y="-11390">fmu[id]?</label>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id56"/>
			<label kind="guard" x="-10345" y="-11509">action == get</label>
			<label kind="synchronisation" x="-10362" y="-11432">fmu[id]?</label>
		</transition>
		<transition>
			<source ref="id58"/>
			<target ref="id60"/>
			<label kind="synchronisation" x="-10531" y="-11509">actionPerformed!</label>
			<label kind="assignment" x="-10481" y="-11534">setValue(var, commitment)</label>
			<nail x="-10387" y="-11492"/>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id58"/>
			<label kind="guard" x="-10591" y="-11432">action == set</label>
			<label kind="synchronisation" x="-10540" y="-11407">fmu[id]?</label>
		</transition>
		<transition>
			<source ref="id60"/>
			<target ref="id59"/>
			<label kind="guard" x="-10225" y="-11305">action == terminate</label>
			<label kind="synchronisation" x="-10191" y="-11279">fmu[id]?</label>
		</transition>
	</template>
	<system>
		// Place template instantiations here.
		MasterA = Interpreter();

		//Max number of tries in the loops is upper bounded by the number of FMUs
		loopS = LoopSolver(nFMU + 1);
		finder = StepFinder(nFMU + 1);

		//The arguments to FMU is Id, numbers of outputs, number of inputs, definition of inputTypes
		
		env_fmu = FMU(env, env_output, env_input, env_inputTypes) ;
		
		load_fmu = FMU(load, load_output, load_input, load_inputTypes) ;
		
		ctrl_fmu = FMU(ctrl, ctrl_output, ctrl_input, ctrl_inputTypes) ;
		
		plant_fmu = FMU(plant, plant_output, plant_input, plant_inputTypes) ;
		

		// List one or more processes to be composed into a system.
		system MasterA,
			env_fmu,load_fmu,ctrl_fmu,plant_fmu,
			loopS, finder;
    </system>
	<queries>
		<query>
			<formula>A[] not deadlock
			</formula>
			<comment>
			</comment>
		</query>
		<query>
			<formula>A&lt;&gt; MasterA.Terminated
			</formula>
			<comment>
			</comment>
		</query>
	</queries>
</nta>